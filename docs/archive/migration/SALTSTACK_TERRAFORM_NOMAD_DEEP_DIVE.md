# Terraform & Nomad: Deep Dive Architecture Guide

> ** Documentation has been moved inline with the code for better maintainability.**
> 
> The comprehensive three-layer orchestration architecture documentation is now embedded directly in the Go source files where the functionality is implemented. This ensures the documentation stays current with code changes and is immediately available to developers.

## Quick Reference

For detailed architecture documentation, see the inline comments in these files:

- **Nomad Job Generation**: `pkg/nomad/job_generator.go` - Complete three-layer architecture guide and orchestration patterns
- **Infrastructure Compiler**: `pkg/bootstrap/check.go` - Eos infrastructure compiler pattern implementation
- **Service Orchestration**: `pkg/orchestrator/` - Multi-layer orchestration coordination
- **Container Management**: `pkg/nomad/` - Nomad job specifications and deployment patterns

## Architecture Status:  ACTIVE

**Date:** September 20, 2025  
**Architecture:**  THREE-LAYER ORCHESTRATION ACTIVE  

┌─────────────────────────────────────────────────────────────┐
│              Layer 1:  (Configuration)             │
│  • Source of Truth ( data)                           │
│  • System Configuration Management                          │
│  • Infrastructure Prerequisites                             │
│  • Cross-component Orchestration                           │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│              Layer 2: Terraform (State)                     │
│  • Infrastructure Provisioning                             │
│  • Nomad Job Resource Management                           │
│  • State Tracking & Rollback                               │
│  • Provider Abstraction                                    │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│              Layer 3: Nomad (Runtime)                       │
│  • Container Lifecycle Management                          │
│  • Service Registration (Consul)                           │
│  • Health Monitoring & Recovery                            │
│  • Resource Allocation & Scheduling                        │
└─────────────────────────────────────────────────────────────┘
```

## Deep Dive: Layer Interactions

### **1. Configuration Flow ( → Variables → Jobs)**

```yaml
# Layer 1:   (Source of Truth)
nomad_service:
  name: jenkins
  environment: production
  config:
    admin_password: secret123
    port: 8080
    datacenter: dc1
    replicas: 2
    cpu: 500
    memory: 1024
```

```python
# Layer 1 → 2:  calls Terraform via eos_terraform.py
def deploy_nomad_service(service_name, environment, service_config):
    workspace = TerraformWorkspace(f"nomad-{service_name}", environment)
    terraform_config = _generate_nomad_service_terraform(service_name, service_config)
    return apply(f"nomad-{service_name}", environment, auto_approve=True)
```

```hcl
# Layer 2: Terraform converts to Nomad job resource
resource "nomad_job" "jenkins" {
  jobspec = templatefile("${path.module}/jenkins.nomad.tpl", {
    admin_password = var.admin_password
    port          = var.port
    datacenter    = var.datacenter
    replicas      = var.replicas
  })
  
  purge_on_destroy = true
  detach          = false
}
```

```hcl
# Layer 3: Nomad job template (generated by Terraform)
job "jenkins" {
  datacenters = ["${datacenter}"]
  type        = "service"
  
  group "jenkins" {
    count = ${replicas}
    
    task "jenkins" {
      driver = "docker"
      config {
        image = "jenkins/jenkins:lts"
        ports = ["http"]
      }
      
      service {
        name = "jenkins"
        port = "http"
        check {
          type = "http"
          path = "/login"
        }
      }
    }
  }
}
```

### **2. State Management Complexity**

#### **Distributed State Coordination**

```python
# /opt/eos//_modules/eos_terraform.py
class TerraformWorkspace:
    def __init__(self, component, environment):
        self.workspace_path = Path(f'/srv/terraform/{environment}/{component}')
        self.state_lock_key = f'terraform/{environment}/{component}/lock'
    
    def acquire_lock(self, ttl=600):
        """Acquire distributed lock via Consul"""
        consul_client = .utils.consul.get_conn()
        session = consul_client.session.create(ttl=ttl)
        acquired = consul_client.kv.put(
            self.state_lock_key,
            __s__['id'],
            acquire=session
        )
        return session if acquired else None
```

#### **State Hierarchy**

1. ** s/**: System facts and configuration
2. **Consul KV Store**: Service discovery and runtime configuration  
3. **Terraform State**: Infrastructure and Nomad job resources
4. **Nomad State**: Container runtime and health status
5. **Vault**: Secrets and credentials

#### **Cross-Layer Dependencies**

```hcl
# Infrastructure must exist before applications
resource "hcloud_server" "nomad_cluster" {
  count = 3
  name  = "nomad-${count.index + 1}"
  # ... server configuration
}

resource "nomad_job" "jenkins" {
  depends_on = [hcloud_server.nomad_cluster]
  jobspec = templatefile("jenkins.nomad.tpl", {
    # Terraform ensures servers exist before deploying jobs
  })
}
```

### **3. Error Handling and Rollback Complexity**

#### **Multi-Layer Rollback Strategy**

```python
def apply(component, environment, auto_approve=False):
    workspace = TerraformWorkspace(component, environment)
    lock = workspace.acquire_lock()
    
    try:
        # Create state snapshot before changes
        snapshot_id = _create_state_snapshot(component, environment)
        
        # Apply Terraform changes
        result = _run_terraform_command(['terraform', 'apply'], workspace.workspace_path)
        
        if result['retcode'] == 0:
            # Success - trigger post-apply hooks
            _run_post_apply_hooks(component, environment, outputs)
            return {'result': True, 'snapshot_id': snapshot_id}
        else:
            # Automatic rollback on failure
            if auto_approve:
                rollback_result = rollback_to_snapshot(component, environment, snapshot_id)
                return {
                    'result': False,
                    'error': result['stderr'],
                    'rollback_attempted': True,
                    'rollback_result': rollback_result
                }
    finally:
        workspace.release_lock(lock)
```

#### **Failure Scenarios and Recovery**

| Failure Point | Impact | Recovery Strategy |
|---------------|--------|-------------------|
| ** State Failure** | Configuration not applied | Retry  state with corrected  |
| **Terraform Apply Failure** | Infrastructure inconsistent | Automatic rollback to previous state |
| **Nomad Job Failure** | Container not scheduled | Terraform re-applies job, Nomad reschedules |
| **Service Health Check Failure** | Service unhealthy | Nomad restarts container, Consul removes from LB |
| **Consul Registration Failure** | Service discovery broken | Nomad re-registers, health checks restore |

### **4. Provider and Integration Complexity**

#### **Multi-Provider Coordination**

```hcl
# Terraform manages multiple providers simultaneously
terraform {
  required_providers {
    nomad = {
      source  = "hashicorp/nomad"
      version = "~> 2.0"
    }
    consul = {
      source  = "hashicorp/consul" 
      version = "~> 2.0"
    }
    vault = {
      source  = "hashicorp/vault"
      version = "~> 3.0"
    }
    hcloud = {
      source  = "hetznercloud/hcloud"
      version = "~> 1.0"
    }
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
```

#### **Cross-Provider Resource Dependencies**

```hcl
# Cloud infrastructure
resource "hcloud_server" "nomad_cluster" {
  # Hetzner cloud servers
}

# Service mesh infrastructure  
resource "consul_config_entry" "proxy_defaults" {
  # Consul Connect configuration
  depends_on = [hcloud_server.nomad_cluster]
}

# Application deployment
resource "nomad_job" "jenkins" {
  # Container workload
  depends_on = [
    hcloud_server.nomad_cluster,
    consul_config_entry.proxy_defaults
  ]
}

# DNS registration
resource "cloudflare_record" "jenkins" {
  # External DNS
  depends_on = [nomad_job.jenkins]
}
```

### **5. Security and Secrets Management**

#### **Multi-Layer Security Model**

```python
# Vault integration in -Terraform bridge
def _get_vault_credentials(provider_name):
    """Retrieve provider credentials from Vault"""
    vault_client = .utils.vault.get_conn()
    
    # Different secret paths for different providers
    secret_paths = {
        'hcloud': 'secret/hetzner/api_token',
        'aws': 'secret/aws/credentials', 
        'cloudflare': 'secret/cloudflare/api_token'
    }
    
    secret = vault_client.read(secret_paths[provider_name])
    return secret['data']
```

```hcl
# Terraform retrieves secrets from Vault
data "vault_generic_secret" "hcloud_token" {
  path = "secret/hetzner/api_token"
}

provider "hcloud" {
  token = data.vault_generic_secret.hcloud_token.data["token"]
}
```

## Operational Complexity Considerations

### **1. Deployment Choreography**

The system must coordinate deployment across multiple layers:

```
1.  validates  configuration
2.  calls Terraform with validated config
3. Terraform acquires distributed lock via Consul
4. Terraform provisions infrastructure if needed
5. Terraform generates Nomad job from template
6. Terraform applies Nomad job as resource
7. Nomad schedules container on available nodes
8. Container starts and registers with Consul
9. Health checks validate service health
10. Consul updates service discovery
11. Terraform records state changes
12.  triggers post-deployment hooks
```

### **2. Monitoring and Observability**

```python
# Multi-layer monitoring integration
def _run_post_apply_hooks(component, environment, outputs):
    """Post-deployment monitoring setup"""
    
    # Register with monitoring systems
    _register_with_prometheus(component, outputs)
    _configure_log_aggregation(component, outputs)
    _setup_alerting_rules(component, environment)
    
    # Update service catalog
    _update_consul_service_catalog(component, outputs)
    
    # Configure backup policies
    _setup_backup_schedules(component, environment)
```

### **3. Multi-Environment Complexity**

```python
# Environment-specific workspace management
class TerraformWorkspace:
    def __init__(self, component, environment='production'):
        self.environment_configs = {
            'development': {
                'replicas': 1,
                'resources': {'cpu': 100, 'memory': 256},
                'storage': 'ephemeral'
            },
            'staging': {
                'replicas': 2, 
                'resources': {'cpu': 200, 'memory': 512},
                'storage': 'persistent'
            },
            'production': {
                'replicas': 3,
                'resources': {'cpu': 500, 'memory': 1024},
                'storage': 'redundant'
            }
        }
```

## Benefits of This Complexity

### **1. Operational Excellence**

- **Unified State Management**: Single source of truth for infrastructure + applications
- **Atomic Operations**: Deploy infrastructure and applications together or not at all
- **Automatic Rollback**: Failed deployments automatically revert to previous known-good state
- **Dependency Resolution**: Infrastructure dependencies automatically satisfied before applications

### **2. Scalability**

- **Multi-Node Ready**: Nomad cluster can span multiple hosts
- **Provider Agnostic**: Same patterns work across Hetzner, AWS, Azure
- **Environment Parity**: Development, staging, production use identical deployment patterns
- **Resource Optimization**: Nomad intelligently schedules based on available resources

### **3. Security**

- **Centralized Secrets**: All credentials managed through Vault
- **Network Segmentation**: Consul Connect provides service mesh security
- **Audit Trail**: Every change tracked through Terraform state and  logs
- **Least Privilege**: Services only access required resources

## Challenges and Mitigations

### **1. Complexity Management**

**Challenge**: Three-layer architecture requires deep understanding
**Mitigation**: 
- Comprehensive documentation (this document)
- User experience abstraction (`eos create jenkins` hides complexity)
- Standardized patterns for all services
- Extensive error handling and logging

### **2. Debugging Difficulty** 

**Challenge**: Failures can occur at any layer
**Mitigation**:
- Layer-specific logging with correlation IDs
- Health check endpoints at each layer
- State inspection tools (`eos status`, `terraform show`, `nomad status`)
- Automatic diagnostics on failure

### **3. Learning Curve**

**Challenge**: Operators need to understand , Terraform, and Nomad
**Mitigation**:
- Role-based access (users vs operators vs architects)
- Abstracted user interface for common tasks
- Runbooks for operational procedures
- Training materials and examples

## Migration Best Practices

### **1. Gradual Migration Strategy**

```
Phase 1: Infrastructure Services (Already Complete)
├── consul ( → direct installation)
├── vault ( → Terraform integration)  
└── nomad ( → cluster management)

Phase 2: High-Priority Applications (Current)
├── jenkins (Docker Compose → Terraform → Nomad)
├── grafana (Enhanced Terraform → Nomad integration)
└── monitoring stack (Unified deployment)

Phase 3: Remaining Services
├── umami, penpot, mattermost
└── legacy applications
```

### **2. Testing Strategy**

```python
# Multi-layer testing approach
def test_service_deployment():
    # Layer 1:  state validation
    assert validate__data(service_config)
    
    # Layer 2: Terraform plan validation  
    plan = terraform_plan(service_name, environment)
    assert plan['valid'] == True
    
    # Layer 3: Nomad job validation
    job_spec = generate_nomad_job(service_config)
    assert nomad_validate_job(job_spec)
    
    # Integration: Full deployment test
    result = deploy_service(service_name, test_config)
    assert result['healthy'] == True
```

## Conclusion

The  → Terraform → Nomad architecture represents a sophisticated approach to modern infrastructure and application management. While complex, this architecture provides:

- **Unified Operations**: Single workflow for infrastructure and applications
- **Enterprise Reliability**: State management, rollback, and dependency resolution
- **Scalable Foundation**: Multi-node, multi-cloud, multi-environment ready
- **Security by Design**: Integrated secrets management and service mesh

The complexity is justified by the operational benefits and provides a solid foundation for scaling from single-node deployments to enterprise-grade multi-region clusters.

This architecture positions Eos as a mature, production-ready orchestration platform that abstracts complexity from users while providing operators with the tools needed for reliable, scalable deployments.