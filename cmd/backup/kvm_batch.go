//go:build linux

// cmd/backup/kvm_batch.go
// Batch backup command for KVM VMs

package backup

import (
	"fmt"
	"time"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_cli"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/kvm"
	"github.com/spf13/cobra"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

var kvmAllCmd = &cobra.Command{
	Use:   "all",
	Short: "Backup all KVM virtual machines",
	Long: `Backup all KVM virtual machines using restic.

Creates external snapshots of running VMs, backs up disk images to restic repository,
and merges snapshots back. Handles multiple VMs with error recovery.

IMPORTANT: Only backs up vda (main disk). Cloud-init seed images (sda/hdd) are skipped
as they are regenerated by eos on VM creation.

Examples:
  # Dry-run to see what would be backed up
  eos backup kvm all --dry-run

  # Backup all running VMs
  eos backup kvm all

  # Include stopped VMs
  eos backup kvm all --include-stopped

  # Exclude specific VMs
  eos backup kvm all --exclude-vm vm1 --exclude-vm vm2

  # Only backup specific VMs
  eos backup kvm all --include-vm vm1 --include-vm vm2

  # Allow crash-consistent backups (no guest agent required)
  eos backup kvm all --allow-crash-consistent

Repository Configuration:
  First run will automatically:
  - Create /etc/eos/backup.yaml config
  - Initialize restic repository at /var/backups/kvm
  - Generate password file at /var/lib/eos/secrets/backup/kvm-backups.password

  KEEP THE PASSWORD FILE SECURE - you'll need it for restore operations.`,

	RunE: eos_cli.Wrap(runKVMBackupAll),
}

func init() {
	kvmCmd.AddCommand(kvmAllCmd)

	// Filtering flags
	kvmAllCmd.Flags().StringSlice("exclude-vm", nil, "VM names to exclude from backup")
	kvmAllCmd.Flags().StringSlice("include-vm", nil, "Only backup these VMs (if specified)")
	kvmAllCmd.Flags().Bool("include-stopped", false, "Include stopped VMs (default: running only)")

	// Backup behavior flags
	kvmAllCmd.Flags().Bool("dry-run", false, "Show what would be backed up without actually backing up")
	kvmAllCmd.Flags().Bool("allow-crash-consistent", false, "Allow backups without guest agent (may corrupt databases)")
	kvmAllCmd.Flags().Bool("continue-on-error", true, "Continue backing up other VMs if one fails")
	kvmAllCmd.Flags().Duration("timeout", 1*time.Hour, "Timeout per VM backup")
	kvmAllCmd.Flags().String("repo", "kvm-backups", "Repository name to use")
}

func runKVMBackupAll(rc *eos_io.RuntimeContext, cmd *cobra.Command, args []string) error {
	logger := otelzap.Ctx(rc.Ctx)

	// Get flags
	excludeVMs, _ := cmd.Flags().GetStringSlice("exclude-vm")
	includeVMs, _ := cmd.Flags().GetStringSlice("include-vm")
	includeStopped, _ := cmd.Flags().GetBool("include-stopped")
	dryRun, _ := cmd.Flags().GetBool("dry-run")
	allowCrashConsistent, _ := cmd.Flags().GetBool("allow-crash-consistent")
	continueOnError, _ := cmd.Flags().GetBool("continue-on-error")
	timeout, _ := cmd.Flags().GetDuration("timeout")
	repoName, _ := cmd.Flags().GetString("repo")

	logger.Info("Starting KVM batch backup",
		zap.Strings("exclude_vms", excludeVMs),
		zap.Strings("include_vms", includeVMs),
		zap.Bool("include_stopped", includeStopped),
		zap.Bool("dry_run", dryRun),
		zap.Bool("allow_crash_consistent", allowCrashConsistent),
		zap.String("repo", repoName))

	// Create orchestrator
	orchestrator, err := kvm.NewVMBackupOrchestrator(rc, kvm.OrchestratorOptions{
		Filter: kvm.BackupFilter{
			ExcludeVMs:     excludeVMs,
			IncludeVMs:     includeVMs,
			IncludeStopped: includeStopped,
		},
		ContinueOnError:      continueOnError,
		Timeout:              timeout,
		DryRun:               dryRun,
		AllowCrashConsistent: allowCrashConsistent,
		RepoName:             repoName,
	})
	if err != nil {
		return fmt.Errorf("failed to create backup orchestrator: %w", err)
	}

	// Perform backup
	summary, err := orchestrator.BackupAll()
	if err != nil {
		return fmt.Errorf("batch backup failed: %w", err)
	}

	// If dry-run, we're done
	if dryRun {
		return nil
	}

	// Print summary
	logger.Info("terminal prompt:", zap.String("output", ""))
	logger.Info("terminal prompt:", zap.String("output", "═══════════════════════════════════════"))
	logger.Info("terminal prompt:", zap.String("output", "Backup Summary"))
	logger.Info("terminal prompt:", zap.String("output", "═══════════════════════════════════════"))
	logger.Info("terminal prompt:", zap.String("output", fmt.Sprintf("Total VMs:      %d", summary.TotalVMs)))
	logger.Info("terminal prompt:", zap.String("output", fmt.Sprintf("Successful:     %d", summary.Successful)))
	logger.Info("terminal prompt:", zap.String("output", fmt.Sprintf("Failed:         %d", summary.Failed)))
	logger.Info("terminal prompt:", zap.String("output", fmt.Sprintf("Skipped:        %d", summary.Skipped)))
	logger.Info("terminal prompt:", zap.String("output", fmt.Sprintf("Total duration: %s", summary.TotalDuration.Round(time.Second))))
	logger.Info("terminal prompt:", zap.String("output", fmt.Sprintf("Total size:     %s", formatBytes(summary.TotalSize))))

	if len(summary.FailedVMs) > 0 {
		logger.Info("terminal prompt:", zap.String("output", ""))
		logger.Info("terminal prompt:", zap.String("output", "Failed VMs:"))
		for _, vmName := range summary.FailedVMs {
			logger.Info("terminal prompt:", zap.String("output", fmt.Sprintf("  - %s", vmName)))
		}
	}

	if len(summary.SkippedVMs) > 0 {
		logger.Info("terminal prompt:", zap.String("output", ""))
		logger.Info("terminal prompt:", zap.String("output", "Skipped VMs:"))
		for _, vmName := range summary.SkippedVMs {
			logger.Info("terminal prompt:", zap.String("output", fmt.Sprintf("  - %s", vmName)))
		}
	}

	logger.Info("terminal prompt:", zap.String("output", "═══════════════════════════════════════"))

	// Return exit code
	if summary.Failed > 0 {
		logger.Error("Batch backup completed with failures",
			zap.Int("failed_count", summary.Failed))
		return fmt.Errorf("%d VM(s) failed to backup", summary.Failed)
	}

	logger.Info("Batch backup completed successfully")
	return nil
}

// formatBytes converts bytes to human-readable format
func formatBytes(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %ciB", float64(bytes)/float64(div), "KMGTPE"[exp])
}
