// Package bionicgpt provides database initialization for automated user creation
//
// This module implements the database user creation that was previously manual.
// This is a CRITICAL shift-left fix: automating user creation prevents deployment failures.
//
// Background:
// - BionicGPT migrations don't create the application user (bionic_application)
// - The app and RAG engine need this user to connect
// - Previous approach: manual user creation after deployment failed
// - New approach: automated creation as part of init process
//
// Code Monkey Cybersecurity - "Cybersecurity. With humans."
package bionicgpt

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

const (
	// InitScriptFilename is the name of the database init script
	InitScriptFilename = "init-db.sh"

	// InitScriptPath is the Docker entrypoint init directory
	// PostgreSQL automatically executes scripts in this directory on first start
	InitScriptDockerPath = "/docker-entrypoint-initdb.d/init-db.sh"
)

// createDatabaseInitScript creates the PostgreSQL initialization script
// This script is mounted into the postgres container and runs automatically
// on first startup via docker-entrypoint-initdb.d mechanism
func (bgi *BionicGPTInstaller) createDatabaseInitScript(ctx context.Context) error {
	logger := otelzap.Ctx(ctx)

	scriptPath := filepath.Join(bgi.config.InstallDir, InitScriptFilename)

	logger.Info("Creating database initialization script",
		zap.String("path", scriptPath))

	// Generate script content
	// This creates the bionic_application user with proper permissions
	// Uses DO $$ block for idempotency (won't fail if user exists)
	content := bgi.generateInitScript()

	// Write script file
	// 0755 = owner read/write/execute, group read/execute, others read/execute
	// Needs execute permission to run in docker-entrypoint-initdb.d
	if err := os.WriteFile(scriptPath, []byte(content), 0755); err != nil {
		return fmt.Errorf("failed to write database init script: %w", err)
	}

	logger.Info("Database init script created successfully",
		zap.String("path", scriptPath),
		zap.String("permissions", "0755"))

	logger.Info("Script will be automatically executed by PostgreSQL on first startup")

	return nil
}

// generateInitScript generates the PostgreSQL initialization script content
func (bgi *BionicGPTInstaller) generateInitScript() string {
	return fmt.Sprintf(`#!/bin/bash
# BionicGPT Database Initialization Script
# Generated by Eos - Code Monkey Cybersecurity
#
# This script is automatically executed by PostgreSQL's docker-entrypoint-initdb.d
# mechanism on the FIRST startup of the database container.
#
# Purpose: Create the bionic_application user needed by BionicGPT application
# and RAG engine to connect to the database.
#
# Security: Uses the same password as the main postgres user (from POSTGRES_PASSWORD env var)
# In production, this should be a separate secret managed by Vault.

set -e  # Exit on any error

echo "════════════════════════════════════════════════════════════════"
echo "BionicGPT Database Initialization"
echo "Creating application user and setting permissions..."
echo "════════════════════════════════════════════════════════════════"

# Run SQL commands as postgres superuser
psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
    -- Create bionic_application user (idempotent - won't fail if exists)
    DO \$\$
    BEGIN
        IF NOT EXISTS (
            SELECT FROM pg_catalog.pg_user WHERE usename = 'bionic_application'
        ) THEN
            CREATE USER bionic_application WITH PASSWORD '%s';
            RAISE NOTICE 'Created user: bionic_application';
        ELSE
            RAISE NOTICE 'User bionic_application already exists, skipping creation';
        END IF;
    END
    \$\$;

    -- Grant database-level privileges
    GRANT ALL PRIVILEGES ON DATABASE "%s" TO bionic_application;
    RAISE NOTICE 'Granted database privileges to bionic_application';

    -- Grant schema-level privileges
    GRANT ALL ON SCHEMA public TO bionic_application;
    RAISE NOTICE 'Granted schema privileges to bionic_application';

    -- Grant privileges on all existing tables and sequences
    GRANT ALL ON ALL TABLES IN SCHEMA public TO bionic_application;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO bionic_application;
    RAISE NOTICE 'Granted table and sequence privileges to bionic_application';

    -- Set default privileges for future tables and sequences
    -- This ensures bionic_application has access to tables created by migrations
    ALTER DEFAULT PRIVILEGES IN SCHEMA public
        GRANT ALL ON TABLES TO bionic_application;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public
        GRANT ALL ON SEQUENCES TO bionic_application;
    RAISE NOTICE 'Set default privileges for future objects';

    -- Verify the user was created successfully
    SELECT
        usename,
        usecreatedb,
        usesuper,
        valuntil
    FROM pg_catalog.pg_user
    WHERE usename = 'bionic_application';
EOSQL

echo "════════════════════════════════════════════════════════════════"
echo "✓ Database initialization completed successfully"
echo "  User: bionic_application"
echo "  Database: %s"
echo "  Privileges: ALL (tables, sequences, schema)"
echo "════════════════════════════════════════════════════════════════"
`,
		bgi.config.PostgresPassword, // Password for bionic_application user
		bgi.config.PostgresDB,        // Database name in CREATE USER notice
		bgi.config.PostgresDB,        // Database name in final echo
	)
}

// updateComposeForInitScript returns the volume mount for the init script
// This should be added to the postgres service volumes in docker-compose.yml
func (bgi *BionicGPTInstaller) getInitScriptVolumeMount() string {
	return fmt.Sprintf("./%s:%s:ro", InitScriptFilename, InitScriptDockerPath)
}
