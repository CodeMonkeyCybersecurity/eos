package ubuntu

import (
	"github.com/CodeMonkeyCybersecurity/eos/pkg/shared"
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/execute"
	"go.uber.org/zap"
)

// configurePAMSafely configures PAM with safety mechanisms and rollback
func (m *MFAManager) configurePAMSafely() error {
	m.logger.Info(" Configuring PAM with safety mechanisms")

	// PAM files to modify
	pamFiles := map[string]string{
		"/etc/pam.d/sudo":  m.getSudoPAMConfig(),
		"/etc/pam.d/su":    m.getSuPAMConfig(),
		"/etc/pam.d/login": m.getLoginPAMConfig(),
	}

	// Exclude login if console bypass is enabled
	if m.config.ConsoleBypassMFA {
		delete(pamFiles, "/etc/pam.d/login")
		m.logger.Info(" Console login will bypass MFA as configured")
	}

	// Update each PAM file atomically
	for file, content := range pamFiles {
		if err := m.updatePAMFileSafely(file, content); err != nil {
			return fmt.Errorf("update %s: %w", file, err)
		}
	}

	return nil
}

// getSudoPAMConfig generates sudo PAM configuration
func (m *MFAManager) getSudoPAMConfig() string {
	var config strings.Builder

	config.WriteString(`#%PAM-1.0
# Secure sudo configuration with MFA - Generated by Eos
# This preserves all existing sudo authorizations while adding MFA

`)

	// Add emergency bypass if configured
	if m.config.EmergencyGroupName != "" {
		config.WriteString(fmt.Sprintf(`# Emergency bypass for %s group (EMERGENCY USE ONLY)
auth [success=done default=ignore] pam_succeed_if.so user ingroup %s
`, m.config.EmergencyGroupName, m.config.EmergencyGroupName))
	}

	// Add service account bypass if configured
	if m.config.ServiceAccountGroup != "" {
		config.WriteString(fmt.Sprintf(`# Service account bypass for automation
auth [success=done default=ignore] pam_succeed_if.so user ingroup %s
`, m.config.ServiceAccountGroup))
	}

	// Add time-based emergency bypass
	config.WriteString(`# Time-based emergency bypass (if flag file exists)
auth [success=done default=ignore] pam_succeed_if.so file /etc/security/.emergency_mfa_bypass

`)

	// Standard authentication first
	config.WriteString(`# Standard password authentication
@include common-auth

`)

	// MFA requirement
	if m.testMode {
		config.WriteString(`# MFA requirement (test mode - nullok allows non-MFA users during testing)
auth required pam_google_authenticator.so nullok
`)
	} else {
		config.WriteString(`# MFA requirement (enforced mode)
auth required pam_google_authenticator.so
`)
	}

	// Standard account and session handling
	config.WriteString(`
# Standard account and session handling
@include common-account
@include common-session-noninteractive
`)

	return config.String()
}

// getSuPAMConfig generates su PAM configuration
func (m *MFAManager) getSuPAMConfig() string {
	var config strings.Builder

	config.WriteString(`#%PAM-1.0
# Secure su configuration with MFA - Generated by Eos

`)

	// Root can always su without additional auth
	config.WriteString(`# Allow root to su without additional authentication
auth sufficient pam_rootok.so

`)

	// Emergency bypasses
	if m.config.EmergencyGroupName != "" {
		config.WriteString(fmt.Sprintf(`# Emergency bypass for %s group
auth [success=done default=ignore] pam_succeed_if.so user ingroup %s
`, m.config.EmergencyGroupName, m.config.EmergencyGroupName))
	}

	// Time-based emergency bypass
	config.WriteString(`# Time-based emergency bypass
auth [success=done default=ignore] pam_succeed_if.so file /etc/security/.emergency_mfa_bypass

`)

	// MFA and password requirement for non-root users
	if m.testMode {
		config.WriteString(`# MFA requirement (test mode)
auth required pam_google_authenticator.so nullok forward_pass
auth required pam_unix.so use_first_pass
`)
	} else {
		config.WriteString(`# MFA requirement (enforced mode)
auth required pam_google_authenticator.so forward_pass
auth required pam_unix.so use_first_pass
`)
	}

	config.WriteString(`
# Standard account and session handling
@include common-account
@include common-session
`)

	return config.String()
}

// getLoginPAMConfig generates login PAM configuration for console access
func (m *MFAManager) getLoginPAMConfig() string {
	var config strings.Builder

	config.WriteString(`#%PAM-1.0
# Secure console login with MFA - Generated by Eos

auth       optional   pam_faildelay.so  delay=3000000
auth [success=ok new_authtok_reqd=ok ignore=ignore user_unknown=bad default=die] pam_securetty.so
auth       requisite  pam_nologin.so

`)

	// Emergency bypasses
	if m.config.EmergencyGroupName != "" {
		config.WriteString(fmt.Sprintf(`# Emergency bypass for %s group
auth [success=done default=ignore] pam_succeed_if.so user ingroup %s
`, m.config.EmergencyGroupName, m.config.EmergencyGroupName))
	}

	// Time-based emergency bypass
	config.WriteString(`# Time-based emergency bypass
auth [success=done default=ignore] pam_succeed_if.so file /etc/security/.emergency_mfa_bypass

`)

	// MFA requirement
	if m.testMode {
		config.WriteString(`# MFA requirement (test mode)
auth required pam_google_authenticator.so nullok forward_pass
auth required pam_unix.so use_first_pass
`)
	} else {
		config.WriteString(`# MFA requirement (enforced mode)
auth required pam_google_authenticator.so forward_pass
auth required pam_unix.so use_first_pass
`)
	}

	config.WriteString(`auth       optional   pam_group.so

@include common-account
@include common-session
@include common-password
`)

	return config.String()
}

// updatePAMFileSafely updates a PAM file with atomic operations and validation
func (m *MFAManager) updatePAMFileSafely(pamFile string, content string) error {
	m.logger.Info(" Updating PAM file", zap.String("file", pamFile))

	// Create backup
	backupName := strings.ReplaceAll(pamFile[1:], "/", "_") + ".backup"
	backupPath := filepath.Join(m.backupDir, backupName)
	if err := m.copyFile(pamFile, backupPath); err != nil {
		return fmt.Errorf("backup %s: %w", pamFile, err)
	}

	// Write to temporary file first
	tmpFile := pamFile + ".tmp"
	if err := os.WriteFile(tmpFile, []byte(content), shared.ConfigFilePerm); err != nil {
		return fmt.Errorf("write temp file: %w", err)
	}

	// Validate PAM configuration syntax
	if err := m.validatePAMConfig(tmpFile); err != nil {
		_ = os.Remove(tmpFile)
		return fmt.Errorf("PAM validation failed: %w", err)
	}

	// Atomic replace
	if err := os.Rename(tmpFile, pamFile); err != nil {
		_ = os.Remove(tmpFile)
		return fmt.Errorf("replace PAM file: %w", err)
	}

	m.logger.Info(" Updated PAM file successfully", zap.String("file", pamFile))
	return nil
}

func (m *MFAManager) validatePAMConfig(path string) error {
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	defer func() { _ = file.Close() }()

	scanner := bufio.NewScanner(file)
	lineNum := 0

	for scanner.Scan() {
		lineNum++
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// PAM includes are valid! Add this check
		if strings.HasPrefix(line, "@include") || strings.HasPrefix(line, "include") {
			continue
		}

		// Check for basic PAM line format
		fields := strings.Fields(line)
		if len(fields) < 3 {
			return fmt.Errorf("line %d: invalid PAM line format: %s", lineNum, line)
		}

		// Validate service type
		validTypes := []string{"auth", "account", "password", "session"}
		if !m.contains(validTypes, fields[0]) {
			// Could be a continuation line with [...]
			if !strings.HasPrefix(fields[0], "[") {
				return fmt.Errorf("line %d: invalid service type: %s", lineNum, fields[0])
			}
		}
	}

	return scanner.Err()
}

// contains checks if a slice contains a string
func (m *MFAManager) contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

// installMFAPackages installs required MFA packages
func (m *MFAManager) installMFAPackages() error {
	m.logger.Info(" Installing MFA packages")

	// Update package list
	if err := execute.RunSimple(m.rc.Ctx, "apt-get", "update"); err != nil {
		return fmt.Errorf("apt-get update: %w", err)
	}

	// Install required packages
	packages := []string{
		"libpam-google-authenticator",
		"qrencode",
		"at", // For emergency bypass scheduling
	}

	args := append([]string{"install", "-y"}, packages...)
	if err := execute.RunSimple(m.rc.Ctx, "apt-get", args...); err != nil {
		return fmt.Errorf("install MFA packages: %w", err)
	}

	// Ensure at daemon is running for emergency bypass
	if err := execute.RunSimple(m.rc.Ctx, "systemctl", "enable", "--now", "atd"); err != nil {
		m.logger.Warn("Failed to enable at daemon", zap.Error(err))
	}

	m.logger.Info(" MFA packages installed successfully")
	return nil
}
