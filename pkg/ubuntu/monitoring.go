package ubuntu

import (
	"github.com/CodeMonkeyCybersecurity/eos/pkg/shared"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/execute"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

// Comprehensive osquery configuration for file integrity monitoring
const osqueryFIMConfig = `{
  "options": {
    "config_plugin": "filesystem",
    "logger_plugin": "filesystem",
    "utc": true
  },
  "schedule": {
    "file_events": {
      "query": "SELECT * FROM file_events;",
      "interval": 300,
      "removed": false,
      "description": "Track file modifications in monitored directories"
    },
    "process_events": {
      "query": "SELECT * FROM process_events WHERE path != '/proc' AND path != '/sys';",
      "interval": 60,
      "removed": false,
      "description": "Monitor process execution events"
    },
    "socket_events": {
      "query": "SELECT * FROM socket_events WHERE family = 2 AND remote_port != 0;",
      "interval": 60,
      "removed": false,
      "description": "Monitor network connections"
    },
    "system_integrity": {
      "query": "SELECT name, path, sha256 FROM hash WHERE path IN ('/bin/bash', '/bin/sh', '/usr/bin/sudo', '/usr/bin/su', '/usr/sbin/sshd');",
      "interval": 3600,
      "removed": false,
      "description": "Monitor critical system binaries"
    },
    "user_accounts": {
      "query": "SELECT * FROM users WHERE type = 'user' AND shell != '/usr/sbin/nologin' AND shell != '/bin/false';",
      "interval": 900,
      "removed": false,
      "description": "Monitor user account changes"
    },
    "sudo_activity": {
      "query": "SELECT * FROM sudoers;",
      "interval": 300,
      "removed": false,
      "description": "Monitor sudo configuration changes"
    },
    "ssh_keys": {
      "query": "SELECT username, key, key_file FROM authorized_keys;",
      "interval": 900,
      "removed": false,
      "description": "Monitor SSH authorized keys"
    },
    "cron_jobs": {
      "query": "SELECT * FROM crontab;",
      "interval": 600,
      "removed": false,
      "description": "Monitor scheduled tasks"
    }
  },
  "file_paths": {
    "configuration": [
      "/etc/%%",
      "/boot/%%",
      "/usr/local/etc/%%"
    ],
    "binaries": [
      "/usr/bin/%%",
      "/usr/sbin/%%",
      "/bin/%%",
      "/sbin/%%",
      "/usr/local/bin/%%",
      "/usr/local/sbin/%%"
    ],
    "libraries": [
      "/usr/lib/%%",
      "/usr/local/lib/%%",
      "/lib/%%"
    ],
    "home_dirs": [
      "/home/%%/.ssh/%%",
      "/home/%%/.bashrc",
      "/home/%%/.bash_profile",
      "/home/%%/.profile"
    ],
    "tmp_dirs": [
      "/tmp/%%",
      "/var/tmp/%%"
    ],
    "logs": [
      "/var/log/auth.log",
      "/var/log/syslog",
      "/var/log/kern.log"
    ]
  },
  "exclude_paths": {
    "configuration": [
      "/etc/mtab",
      "/etc/resolv.conf"
    ],
    "binaries": [
      "/usr/bin/.*\\.dpkg-.*",
      "/usr/sbin/.*\\.dpkg-.*"
    ]
  },
  "events": {
    "disable_subscribers": ["user_events"]
  }
}`

// Osquery status monitoring script
const osqueryStatusScript = `#!/bin/bash
# Osquery security status script
# Generated by Eos

set -euo pipefail

COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_YELLOW='\033[1;33m'
COLOR_BLUE='\033[0;34m'
COLOR_RESET='\033[0m'

print_header() {
    echo -e "${COLOR_BLUE}=== Osquery Security Monitoring Status - $(date) ===${COLOR_RESET}"
    echo
}

check_osquery_status() {
    echo -e "${COLOR_YELLOW}Osquery Service Status:${COLOR_RESET}"
    systemctl status osqueryd --no-pager | head -10
    echo
}

show_recent_events() {
    echo -e "${COLOR_YELLOW}Recent File Events (last 24h):${COLOR_RESET}"
    echo "SELECT target_path, action, time FROM file_events WHERE time > datetime('now', '-24 hours') ORDER BY time DESC LIMIT 20;" | osqueryi --json | jq -r '.[] | "\(.time) \(.action) \(.target_path)"' 2>/dev/null || echo "  No recent file events"
    echo
    
    echo -e "${COLOR_YELLOW}Recent Process Events (last 1h):${COLOR_RESET}"
    echo "SELECT path, cmdline, time FROM process_events WHERE time > datetime('now', '-1 hour') ORDER BY time DESC LIMIT 10;" | osqueryi --json | jq -r '.[] | "\(.time) \(.path) \(.cmdline)"' 2>/dev/null || echo "  No recent process events"
    echo
}

check_critical_files() {
    echo -e "${COLOR_YELLOW}Critical System Files Status:${COLOR_RESET}"
    echo "SELECT path, sha256, mtime FROM hash WHERE path IN ('/etc/passwd', '/etc/shadow', '/etc/sudoers') ORDER BY path;" | osqueryi --json | jq -r '.[] | "\(.path): \(.sha256) (modified: \(.mtime))"' 2>/dev/null || echo "  Unable to check file hashes"
    echo
}

show_active_connections() {
    echo -e "${COLOR_YELLOW}Active Network Connections:${COLOR_RESET}"
    echo "SELECT local_port, remote_address, remote_port, state FROM socket_events WHERE family = 2 AND state = 'LISTEN' LIMIT 10;" | osqueryi --json | jq -r '.[] | ":\(.local_port) <- \(.remote_address):\(.remote_port) (\(.state))"' 2>/dev/null || echo "  No network connection data"
    echo
}

show_user_activity() {
    echo -e "${COLOR_YELLOW}User Activity Summary:${COLOR_RESET}"
    echo "SELECT username, shell, directory FROM users WHERE type = 'user' AND shell NOT IN ('/usr/sbin/nologin', '/bin/false') ORDER BY username;" | osqueryi --json | jq -r '.[] | "\(.username): \(.shell) -> \(.directory)"' 2>/dev/null || echo "  Unable to get user data"
    echo
}

check_audit_status() {
    echo -e "${COLOR_YELLOW}Auditd Service Status:${COLOR_RESET}"
    systemctl status auditd --no-pager | head -5
    echo
    
    echo -e "${COLOR_YELLOW}Active Audit Rules:${COLOR_RESET}"
    auditctl -l | wc -l | xargs echo "  Active rules:"
    echo
    
    echo -e "${COLOR_YELLOW}Recent Audit Events:${COLOR_RESET}"
    aureport --summary | head -10
    echo
}

show_help() {
    echo "Usage: $0 [option]"
    echo "Options:"
    echo "  status     - Show service status"
    echo "  files      - Check critical file integrity"
    echo "  events     - Show recent security events"
    echo "  network    - Show network activity"
    echo "  users      - Show user activity"
    echo "  audit      - Show audit system status"
    echo "  help       - Show this help message"
    echo
    echo "Without options, shows full security report"
}

case "${1:-}" in
    status)
        check_osquery_status
        check_audit_status
        ;;
    files)
        check_critical_files
        ;;
    events)
        show_recent_events
        ;;
    network)
        show_active_connections
        ;;
    users)
        show_user_activity
        ;;
    audit)
        check_audit_status
        ;;
    help)
        show_help
        ;;
    *)
        print_header
        check_osquery_status
        check_audit_status
        check_critical_files
        show_recent_events
        show_user_activity
        ;;
esac
`

func configureEnhancedMonitoring(rc *eos_io.RuntimeContext) error {
	if rc == nil || rc.Ctx == nil {
		return fmt.Errorf("runtime context is nil")
	}
	logger := otelzap.Ctx(rc.Ctx)
	logger.Info(" Configuring enhanced security monitoring with Osquery")

	// Configure enhanced Osquery for file integrity monitoring
	if err := configureOsqueryFIM(rc); err != nil {
		return fmt.Errorf("configure osquery FIM: %w", err)
	}

	// Enhance existing Auditd configuration with additional security rules
	if err := enhanceAuditdConfig(rc); err != nil {
		return fmt.Errorf("enhance auditd config: %w", err)
	}

	// Create monitoring management script
	if err := createMonitoringScript(rc); err != nil {
		return fmt.Errorf("create monitoring script: %w", err)
	}

	logger.Info(" Enhanced security monitoring configured successfully")
	return nil
}

func configureOsqueryFIM(rc *eos_io.RuntimeContext) error {
	if rc == nil || rc.Ctx == nil {
		return fmt.Errorf("runtime context is nil")
	}
	logger := otelzap.Ctx(rc.Ctx)
	logger.Info(" Configuring Osquery for file integrity monitoring")

	// Ensure osquery config directory exists
	configDir := "/etc/osquery"
	if err := os.MkdirAll(configDir, shared.ServiceDirPerm); err != nil {
		return fmt.Errorf("create osquery config directory: %w", err)
	}

	// Write comprehensive FIM configuration
	configPath := filepath.Join(configDir, "osquery.conf")
	if err := os.WriteFile(configPath, []byte(osqueryFIMConfig), shared.ConfigFilePerm); err != nil {
		return fmt.Errorf("write osquery config: %w", err)
	}

	logger.Info(" Osquery FIM configuration written",
		zap.String("config_path", configPath))

	// Ensure osquery log directory exists with proper permissions
	logDir := "/var/log/osquery"
	if err := os.MkdirAll(logDir, shared.ServiceDirPerm); err != nil {
		return fmt.Errorf("create osquery log directory: %w", err)
	}

	// Set proper ownership for osquery directories (only if osquery user exists)
	if err := execute.RunSimple(rc.Ctx, "id", "osquery"); err == nil {
		if err := execute.RunSimple(rc.Ctx, "chown", "-R", "osquery:osquery", logDir); err != nil {
			logger.Warn(" Failed to set osquery log directory ownership", zap.Error(err))
		}
	} else {
		logger.Info(" Osquery user not found, skipping ownership change")
	}

	// Restart osquery to apply new configuration
	if err := execute.RunSimple(rc.Ctx, "systemctl", "restart", "osqueryd"); err != nil {
		return fmt.Errorf("restart osqueryd: %w", err)
	}

	if err := execute.RunSimple(rc.Ctx, "systemctl", "enable", "osqueryd"); err != nil {
		return fmt.Errorf("enable osqueryd: %w", err)
	}

	logger.Info(" Osquery FIM service configured and started")
	return nil
}

func enhanceAuditdConfig(rc *eos_io.RuntimeContext) error {
	if rc == nil || rc.Ctx == nil {
		return fmt.Errorf("runtime context is nil")
	}
	logger := otelzap.Ctx(rc.Ctx)
	logger.Info(" Enhancing existing Auditd configuration with additional security rules")

	// Add enhanced security rules as a supplementary file
	rulesDir := "/etc/audit/rules.d"
	enhancedRulesPath := filepath.Join(rulesDir, "60-eos-enhanced.rules")

	// Create enhanced rules that complement the existing basic rules
	enhancedRules := `# Enhanced Eos Security Audit Rules (supplement to hardening.rules)
# Generated by Eos enhanced monitoring

# Rate limit and buffer optimizations  
-r 1000

# Monitor file access attempts to sensitive locations
-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -k file_access_denied
-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -k file_access_denied
-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -k file_access_denied
-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -k file_access_denied

# Monitor network configuration changes
-w /etc/hosts -p wa -k network_config
-w /etc/network/ -p wa -k network_config
-w /etc/netplan/ -p wa -k network_config

# Monitor systemd services and init
-w /etc/systemd/ -p wa -k systemd
-w /lib/systemd/ -p wa -k systemd

# Monitor file permission changes
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -k perm_mod
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -k perm_mod
-a always,exit -F arch=b64 -S chown,fchown,fchownat,lchown -k perm_mod
-a always,exit -F arch=b32 -S chown,fchown,fchownat,lchown -k perm_mod

# Monitor file system mounts
-a always,exit -F arch=b64 -S mount -k mounts
-a always,exit -F arch=b32 -S mount -k mounts

# Monitor login/logout events
-w /var/log/lastlog -p wa -k logins
-w /var/run/faillock/ -p wa -k logins

# Monitor SSH keys and authorized_keys
-w /home/ -p wa -k ssh_keys -F dir=/home -F subdir=.ssh

# Monitor suspicious execution in tmp directories
-w /tmp/ -p x -k suspicious_exec
-w /var/tmp/ -p x -k suspicious_exec

# Monitor critical system libraries
-w /lib/ -p wa -k system_libs
-w /lib64/ -p wa -k system_libs
-w /usr/lib/ -p wa -k system_libs

# Monitor process execution of critical binaries
-a always,exit -F arch=b64 -S execve -F path=/bin/su -k privileged_exec
-a always,exit -F arch=b32 -S execve -F path=/bin/su -k privileged_exec
-a always,exit -F arch=b64 -S execve -F path=/usr/bin/sudo -k privileged_exec
-a always,exit -F arch=b32 -S execve -F path=/usr/bin/sudo -k privileged_exec

# Monitor kernel module operations
-a always,exit -F arch=b64 -S init_module,delete_module -k modules
-a always,exit -F arch=b32 -S init_module,delete_module -k modules
`

	if err := os.WriteFile(enhancedRulesPath, []byte(enhancedRules), shared.SecureConfigFilePerm); err != nil {
		return fmt.Errorf("write enhanced audit rules: %w", err)
	}

	logger.Info(" Enhanced audit rules written",
		zap.String("rules_path", enhancedRulesPath))

	// Restart auditd to load the new rules (this will also reload the existing rules)
	if err := execute.RunSimple(rc.Ctx, "systemctl", "restart", "auditd"); err != nil {
		logger.Warn(" Failed to restart auditd, rules will load on next boot", zap.Error(err))
	} else {
		logger.Info(" Auditd restarted with enhanced rules")
	}

	// Verify total audit rules are loaded - count lines from auditctl output
	if output, err := execute.Run(rc.Ctx, execute.Options{
		Command: "auditctl",
		Args:    []string{"-l"},
	}); err != nil {
		logger.Warn(" Failed to verify audit rules", zap.Error(err))
	} else {
		lines := strings.Split(strings.TrimSpace(output), "\n")
		ruleCount := len(lines)
		if output == "" {
			ruleCount = 0
		}
		logger.Info(" Total audit rules loaded",
			zap.Int("rule_count", ruleCount))
	}

	return nil
}

func createMonitoringScript(rc *eos_io.RuntimeContext) error {
	if rc == nil || rc.Ctx == nil {
		return fmt.Errorf("runtime context is nil")
	}
	logger := otelzap.Ctx(rc.Ctx)
	logger.Info(" Creating security monitoring management script")

	scriptPath := "/usr/local/bin/security-monitor"
	if err := os.WriteFile(scriptPath, []byte(osqueryStatusScript), shared.ExecutablePerm); err != nil {
		return fmt.Errorf("write monitoring script: %w", err)
	}

	logger.Info(" Security monitoring script created",
		zap.String("path", scriptPath),
		zap.String("usage", "Run 'security-monitor' for security status"))

	return nil
}
