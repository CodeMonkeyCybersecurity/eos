package config

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_unix"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/execute"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/network"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/shared"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

// Generate creates the Consul configuration file
// Migrated from cmd/create/consul.go generateConsulConfig
func Generate(rc *eos_io.RuntimeContext, cfg *ConsulConfig) error {
	// CRITICAL: Prevent panic on nil config
	if cfg == nil {
		return fmt.Errorf("consul config cannot be nil")
	}

	log := otelzap.Ctx(rc.Ctx)

	// ASSESS - Prepare configuration parameters
	log.Info("Assessing Consul configuration requirements",
		zap.String("datacenter", cfg.DatacenterName),
		zap.Bool("vault_integration", cfg.VaultAvailable))

	hostname := eos_unix.GetInternalHostname()
	nodeName := fmt.Sprintf("%s-consul", hostname)

	logLevel := "INFO"
	if cfg.EnableDebugLogging {
		logLevel = "DEBUG"
	}

	// Detect the correct network interface for Consul binding
	log.Info("Detecting network interface for Consul")
	iface, err := network.SelectInterface(rc)
	if err != nil {
		return fmt.Errorf("failed to select network interface: %w", err)
	}

	log.Info("Using network interface for Consul",
		zap.String("interface", iface.Name),
		zap.String("bind_addr", iface.IP))

	// INTERVENE - Generate and write configuration
	log.Info("Generating Consul configuration")

	// Default to single-node if not specified
	bootstrapExpect := cfg.BootstrapExpect
	if bootstrapExpect == 0 {
		bootstrapExpect = 1
	}

	// Build server mode configuration
	var serverConfig string
	if bootstrapExpect == 1 {
		// Single-node: use bootstrap mode
		serverConfig = `server = true
bootstrap = true  # Single-node cluster`
	} else {
		// Multi-node: use bootstrap_expect
		serverConfig = fmt.Sprintf(`server = true
bootstrap_expect = %d  # Multi-node cluster`, bootstrapExpect)
	}

	config := fmt.Sprintf(`# Consul Configuration for Scaling and Service Discovery
# Generated by Eos at %s

# Datacenter identification
datacenter = "%s"
node_name = "%s"

# Data directory
data_dir = "/opt/consul"

# Server mode configuration
%s

# Custom ports configuration for Eos
ports {
  http = %d      # HTTP API (Eos standard instead of 8500)
  https = -1       # Disabled for now
  grpc = 8502      # Keep default for internal communication
  dns = 8600       # Keep default DNS
  serf_lan = 8301  # Keep default for LAN gossip
  serf_wan = 8302  # Keep default for WAN gossip
  server = 8300    # Keep default for RPC
}

# Network configuration
client_addr = "0.0.0.0"  # Accept connections from anywhere
bind_addr = "%s"  # Primary interface IP

# Advertise addresses for when you add more nodes
advertise_addr = "%s"
advertise_addr_wan = "%s"

# UI enabled for management
ui_config {
  enabled = true
}

# DNS configuration for service discovery
dns_config {
  allow_stale = true
  max_stale = "2s"
  node_ttl = "30s"
  service_ttl = {
    "*" = "5s"
  }
  enable_truncate = true
}

# Performance settings optimized for growth
performance {
  raft_multiplier = 1  # Low latency for single node
  leave_drain_time = "5s"
  rpc_hold_timeout = "7s"
}

# Logging configuration
log_level = "%s"
log_json = true

# Enable metrics for monitoring
telemetry {
  prometheus_retention_time = "60s"
  disable_hostname = false
  statsd_address = "127.0.0.1:8125"
}

# Connect settings (service mesh ready)
connect {
  enabled = true
}

# Autopilot for automatic cluster management
autopilot {
  cleanup_dead_servers = true
  last_contact_threshold = "200ms"
  max_trailing_logs = 250
  min_quorum = 3  # Prepares for 3-node minimum
  server_stabilization_time = "10s"
}

# Script checks disabled for security (enable only with ACLs)
# enable_script_checks = false  # Use enable_local_script_checks instead
enable_local_script_checks = true

# Security settings
acl = {
  enabled = false
  default_policy = "allow"
  # Prepared for future ACL enablement
}

# Encryption settings (prepared for production)
# encrypt = "base64-key-here"  # Uncomment and set for production

# TLS settings (prepared for production)
# tls {
#   defaults {
#     verify_incoming = true
#     verify_outgoing = true
#   }
#   internal_rpc {
#     verify_server_hostname = true
#   }
# }

# Watches for external integration
watches = [
  {
    type = "services"
    handler_type = "script"
    args = ["/usr/local/bin/consul-vault-helper", "watch"]
  }
]
`, time.Now().Format(time.RFC3339), cfg.DatacenterName, nodeName, serverConfig, shared.PortConsul, iface.IP, iface.IP, iface.IP, logLevel)

	configPath := "/etc/consul.d/consul.hcl"

	// Log first 30 lines of config for debugging (before writing)
	configLines := strings.Split(config, "\n")
	previewLines := 30
	if len(configLines) < previewLines {
		previewLines = len(configLines)
	}
	configPreview := strings.Join(configLines[:previewLines], "\n")
	log.Info("Generated Consul configuration (first 30 lines)",
		zap.String("config_preview", configPreview),
		zap.Int("total_lines", len(configLines)))

	// CRITICAL: Use atomic write pattern to avoid TOCTOU race
	// Write to temp file first, then atomic rename
	// This prevents:
	// 1. Race between check and write
	// 2. Partial writes if process crashes
	// 3. Reading corrupted config during write

	tempPath := configPath + ".tmp"

	// Write to temp file with sync
	file, err := os.OpenFile(tempPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0640)
	if err != nil {
		return fmt.Errorf("failed to open temp config file: %w", err)
	}

	// Ensure temp file is cleaned up on error
	var writeSuccess bool
	defer func() {
		file.Close()
		if !writeSuccess {
			os.Remove(tempPath)
		}
	}()

	if _, err := file.WriteString(config); err != nil {
		return fmt.Errorf("failed to write consul config to temp file: %w", err)
	}

	// Sync to disk before rename - ensures data is persisted
	if err := file.Sync(); err != nil {
		return fmt.Errorf("failed to sync config to disk: %w", err)
	}

	if err := file.Close(); err != nil {
		return fmt.Errorf("failed to close temp config file: %w", err)
	}

	// Check if config actually changed (after writing to temp)
	// This avoids unnecessary renames and Consul reloads
	if existingConfig, err := os.ReadFile(configPath); err == nil {
		if string(existingConfig) == config {
			log.Info("Configuration unchanged, skipping atomic rename",
				zap.String("path", configPath))
			os.Remove(tempPath) // Clean up temp file
			return nil
		}
		log.Info("Configuration changed, performing atomic rename",
			zap.String("path", configPath),
			zap.Int("old_size", len(existingConfig)),
			zap.Int("new_size", len(config)))
	}

	// Force correct permissions before rename
	if err := os.Chmod(tempPath, 0640); err != nil {
		return fmt.Errorf("failed to set temp config permissions: %w", err)
	}

	// Atomic rename - this is the critical operation
	// Rename is atomic on POSIX systems, preventing partial reads
	if err := os.Rename(tempPath, configPath); err != nil {
		return fmt.Errorf("failed to atomically rename config: %w", err)
	}

	writeSuccess = true // Prevent temp file cleanup

	// Set ownership (after successful rename)
	if err := execute.RunSimple(rc.Ctx, "chown", "consul:consul", configPath); err != nil {
		return fmt.Errorf("failed to set config ownership: %w", err)
	}

	// EVALUATE - Verify configuration was written
	log.Info("Evaluating Consul configuration")

	// Check if file exists with correct permissions
	info, err := os.Stat(configPath)
	if err != nil {
		return fmt.Errorf("failed to verify config file: %w", err)
	}

	if info.Mode().Perm() != 0640 {
		log.Warn("Config file permissions not as expected",
			zap.String("expected", "0640"),
			zap.String("actual", info.Mode().Perm().String()))
	}

	log.Info("Consul configuration written successfully",
		zap.String("path", configPath),
		zap.String("datacenter", cfg.DatacenterName),
		zap.String("node_name", nodeName))

	return nil
}
