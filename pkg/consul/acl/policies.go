// pkg/consul/acl/policies.go
//
// Consul ACL Policy Management
//
// This module provides helpers for creating and managing Consul ACL policies.
// Policies define what permissions tokens will have when generated by Vault.

package acl

import (
	"fmt"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	consulapi "github.com/hashicorp/consul/api"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

// PolicyExists checks if a Consul ACL policy exists
func PolicyExists(rc *eos_io.RuntimeContext, consulClient *consulapi.Client, policyName string) (bool, error) {
	logger := otelzap.Ctx(rc.Ctx)

	logger.Debug("Checking if Consul policy exists",
		zap.String("policy", policyName))

	// Try to read the policy
	_, _, err := consulClient.ACL().PolicyReadByName(policyName, nil)
	if err != nil {
		// Check if error is "not found" vs actual error
		if err.Error() == "Unexpected response code: 404 (Policy not found)" {
			logger.Debug("Consul policy does not exist",
				zap.String("policy", policyName))
			return false, nil
		}
		return false, fmt.Errorf("failed to check if policy exists: %w", err)
	}

	logger.Debug("Consul policy exists",
		zap.String("policy", policyName))
	return true, nil
}

// CreatePolicy creates a Consul ACL policy
//
// Parameters:
//   - rc: Runtime context
//   - consulClient: Consul client (must have ACL write permissions)
//   - name: Policy name (e.g., "eos-policy", "vault-mgmt-policy")
//   - description: Human-readable description
//   - rules: HCL policy rules
//
// Returns:
//   - Policy ID
//   - Error if creation fails
//
// Example:
//
//	policyRules := acl.GetDefaultEOSPolicy()
//	policyID, err := acl.CreatePolicy(rc, consulClient, "eos-policy", "EOS orchestration policy", policyRules)
func CreatePolicy(
	rc *eos_io.RuntimeContext,
	consulClient *consulapi.Client,
	name string,
	description string,
	rules string,
) (string, error) {
	logger := otelzap.Ctx(rc.Ctx)

	logger.Info("Creating Consul ACL policy",
		zap.String("policy", name))

	// ASSESS - Check if policy already exists
	exists, err := PolicyExists(rc, consulClient, name)
	if err != nil {
		return "", err
	}

	if exists {
		logger.Info("Consul policy already exists",
			zap.String("policy", name))

		// Read existing policy to get ID
		policy, _, err := consulClient.ACL().PolicyReadByName(name, nil)
		if err != nil {
			return "", fmt.Errorf("failed to read existing policy: %w", err)
		}

		// SECURITY P0: Defensive check against Consul SDK returning nil policy with nil error
		// This prevents nil pointer dereference when SDK has unexpected behavior
		if policy == nil {
			return "", fmt.Errorf("policy %s exists but API returned nil (possible Consul SDK bug)", name)
		}

		return policy.ID, nil
	}

	// INTERVENE - Create the policy
	policy := &consulapi.ACLPolicy{
		Name:        name,
		Description: description,
		Rules:       rules,
	}

	createdPolicy, _, err := consulClient.ACL().PolicyCreate(policy, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create Consul policy %s: %w\n"+
			"Remediation:\n"+
			"  - Check Consul token has ACL write permissions\n"+
			"  - Verify policy HCL syntax is valid\n"+
			"  - Check Consul logs: journalctl -u consul -n 50",
			name, err)
	}

	logger.Info("Consul ACL policy created",
		zap.String("policy", name),
		zap.String("id", createdPolicy.ID))

	return createdPolicy.ID, nil
}

// GetDefaultEOSPolicy returns the default HCL policy for EOS applications
func GetDefaultEOSPolicy() string {
	return `# EOS Orchestration Policy
# Allows EOS to manage services and configuration

# Allow EOS to read/write its own config in KV
key_prefix "config/eos/" {
  policy = "write"
}

# Allow EOS to read config for services it manages
key_prefix "config/" {
  policy = "read"
}

# Allow EOS to register/deregister services
service_prefix "" {
  policy = "write"
}

# Allow EOS to read service catalog (for service discovery)
service_prefix "" {
  policy = "read"
}

# Allow EOS to read node information
node_prefix "" {
  policy = "read"
}

# Allow EOS to write node metadata
key_prefix "nodes/" {
  policy = "write"
}

# Allow EOS to perform health checks
agent_prefix "" {
  policy = "read"
}
`
}

// GetDefaultVaultMgmtPolicy returns the HCL policy for Vault to manage Consul ACLs
func GetDefaultVaultMgmtPolicy() string {
	return `# Vault Management Policy
# Allows Vault's Consul secrets engine to create/manage ACL tokens

# Allow Vault to manage ACL tokens
acl = "write"

# Allow Vault to read service catalog (for validation)
service_prefix "" {
  policy = "read"
  intentions = "read"
}

# Allow Vault to read nodes (for validation)
node_prefix "" {
  policy = "read"
}

# Allow Vault to manage KV for token metadata
key_prefix "vault/" {
  policy = "write"
}
`
}

// GetDefaultReadOnlyPolicy returns a read-only policy for limited applications
func GetDefaultReadOnlyPolicy() string {
	return `# Read-Only Policy
# Allows applications to discover services and read config

# Allow reading all config
key_prefix "config/" {
  policy = "read"
}

# Allow service discovery (read only)
service_prefix "" {
  policy = "read"
}

# Allow reading node information
node_prefix "" {
  policy = "read"
}
`
}

// CreateDefaultPolicies creates all default EOS policies in Consul
//
// This creates:
//   - eos-policy: For EOS orchestration
//   - vault-mgmt-policy: For Vault to manage tokens
//   - readonly-policy: For read-only applications
//
// Example:
//
//	policies, err := acl.CreateDefaultPolicies(rc, consulClient)
//	if err != nil {
//	    return fmt.Errorf("failed to create default policies: %w", err)
//	}
//	logger.Info("Created policies", zap.Strings("policies", policies))
func CreateDefaultPolicies(rc *eos_io.RuntimeContext, consulClient *consulapi.Client) ([]string, error) {
	logger := otelzap.Ctx(rc.Ctx)

	logger.Info("Creating default Consul ACL policies")

	policies := []struct {
		Name        string
		Description string
		Rules       string
	}{
		{
			Name:        "eos-policy",
			Description: "Policy for EOS orchestration system",
			Rules:       GetDefaultEOSPolicy(),
		},
		{
			Name:        "vault-mgmt-policy",
			Description: "Policy for Vault to manage Consul ACL tokens",
			Rules:       GetDefaultVaultMgmtPolicy(),
		},
		{
			Name:        "readonly-policy",
			Description: "Read-only policy for applications",
			Rules:       GetDefaultReadOnlyPolicy(),
		},
	}

	var created []string

	for _, p := range policies {
		policyID, err := CreatePolicy(rc, consulClient, p.Name, p.Description, p.Rules)
		if err != nil {
			logger.Warn("Failed to create policy",
				zap.String("policy", p.Name),
				zap.Error(err))
			// Continue with other policies
		} else {
			logger.Info("Created policy",
				zap.String("policy", p.Name),
				zap.String("id", policyID))
			created = append(created, p.Name)
		}
	}

	if len(created) == 0 {
		return nil, fmt.Errorf("failed to create any policies")
	}

	logger.Info("Default policies created",
		zap.Strings("policies", created))

	return created, nil
}
