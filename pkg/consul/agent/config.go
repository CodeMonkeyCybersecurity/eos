// pkg/consul/agent/config.go
//
// HCL configuration generation for Consul agents.
//
// Last Updated: 2025-01-24

package agent

import (
	"fmt"
	"strings"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/consul"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

// GenerateAgentHCL creates a Consul agent configuration file in HCL format.
//
// This generates a complete agent configuration with:
//   - Datacenter and node identification
//   - Server or client mode configuration
//   - Cluster join addresses
//   - Service mesh (Connect) settings
//   - ACL configuration
//   - UI settings
//   - Service registrations
//
// All values use centralized constants. No hardcoded values.
//
// Parameters:
//   - rc: RuntimeContext for logging
//   - config: Agent configuration
//
// Returns:
//   - string: Complete HCL configuration
//   - error: Any generation error
func GenerateAgentHCL(rc *eos_io.RuntimeContext, config AgentConfig) (string, error) {
	logger := otelzap.Ctx(rc.Ctx)

	logger.Info("Generating Consul agent HCL configuration",
		zap.String("node_name", config.NodeName),
		zap.String("mode", string(config.Mode)))

	// Validate required fields
	if config.NodeName == "" {
		return "", fmt.Errorf("node_name is required")
	}
	if config.Datacenter == "" {
		return "", fmt.Errorf("datacenter is required")
	}

	// Set defaults
	if config.LogLevel == "" {
		config.LogLevel = "INFO"
	}
	if config.DataDir == "" {
		config.DataDir = consul.ConsulOptDir
	}

	// Build HCL
	var hcl strings.Builder

	// Header
	hcl.WriteString("# Generated by Eos\n")
	hcl.WriteString(fmt.Sprintf("# Node: %s\n", config.NodeName))
	hcl.WriteString(fmt.Sprintf("# Datacenter: %s\n", config.Datacenter))
	hcl.WriteString(fmt.Sprintf("# Mode: %s\n\n", config.Mode))

	// Basic configuration
	hcl.WriteString(fmt.Sprintf("datacenter = \"%s\"\n", config.Datacenter))
	hcl.WriteString(fmt.Sprintf("node_name  = \"%s\"\n", config.NodeName))
	hcl.WriteString(fmt.Sprintf("data_dir   = \"%s\"\n", config.DataDir))
	hcl.WriteString(fmt.Sprintf("log_level  = \"%s\"\n\n", config.LogLevel))

	// Server/Client mode
	switch config.Mode {
	case ModeServer:
		hcl.WriteString("server = true\n")
		if config.BootstrapExpect > 0 {
			hcl.WriteString(fmt.Sprintf("bootstrap_expect = %d\n\n", config.BootstrapExpect))
		}
	case ModeClient:
		hcl.WriteString("server = false\n\n")
	case ModeDev:
		hcl.WriteString("server = true\n")
		hcl.WriteString("bootstrap_expect = 1\n")
		hcl.WriteString("ui_config {\n")
		hcl.WriteString("  enabled = true\n")
		hcl.WriteString("}\n\n")
	}

	// Retry join
	if len(config.RetryJoin) > 0 {
		hcl.WriteString("retry_join = [\n")
		for _, addr := range config.RetryJoin {
			hcl.WriteString(fmt.Sprintf("  \"%s\",\n", addr))
		}
		hcl.WriteString("]\n\n")
	}

	// Bind address
	if config.BindAddress != "" {
		hcl.WriteString(fmt.Sprintf("bind_addr = \"%s\"\n", config.BindAddress))
	} else {
		hcl.WriteString("bind_addr = \"{{ GetPrivateInterfaces | attr \\\"address\\\" }}\"\n")
	}

	if config.AdvertiseAddr != "" {
		hcl.WriteString(fmt.Sprintf("advertise_addr = \"%s\"\n", config.AdvertiseAddr))
	}
	hcl.WriteString("\n")

	// UI configuration
	if config.EnableUI {
		hcl.WriteString("ui_config {\n")
		hcl.WriteString("  enabled = true\n")
		hcl.WriteString("}\n\n")
	}

	// Connect (service mesh)
	if config.EnableConnect {
		hcl.WriteString("connect {\n")
		hcl.WriteString("  enabled = true\n")
		hcl.WriteString("}\n\n")
		hcl.WriteString("ports {\n")
		hcl.WriteString(fmt.Sprintf("  grpc = %d\n", consul.PortgRPC))
		hcl.WriteString("}\n\n")
	}

	// ACL configuration
	if config.EnableACL {
		hcl.WriteString("acl {\n")
		hcl.WriteString("  enabled = true\n")
		hcl.WriteString("  default_policy = \"deny\"\n")
		hcl.WriteString("  enable_token_persistence = true\n")
		hcl.WriteString("}\n\n")
	}

	// Node metadata
	if len(config.Meta) > 0 {
		hcl.WriteString("node_meta = {\n")
		for key, value := range config.Meta {
			hcl.WriteString(fmt.Sprintf("  \"%s\" = \"%s\"\n", key, value))
		}
		hcl.WriteString("}\n\n")
	}

	// Service registrations
	if len(config.Services) > 0 {
		hcl.WriteString("# Service registrations\n")
		for _, svc := range config.Services {
			hcl.WriteString(generateServiceHCL(svc))
			hcl.WriteString("\n")
		}
	}

	logger.Info("Generated Consul agent HCL",
		zap.Int("size_bytes", hcl.Len()))

	return hcl.String(), nil
}

// generateServiceHCL generates HCL for a single service registration
func generateServiceHCL(svc ServiceDefinition) string {
	var hcl strings.Builder

	hcl.WriteString("service {\n")
	hcl.WriteString(fmt.Sprintf("  id   = \"%s\"\n", svc.ID))
	hcl.WriteString(fmt.Sprintf("  name = \"%s\"\n", svc.Name))
	hcl.WriteString(fmt.Sprintf("  port = %d\n", svc.Port))

	if svc.Address != "" {
		hcl.WriteString(fmt.Sprintf("  address = \"%s\"\n", svc.Address))
	}

	if len(svc.Tags) > 0 {
		hcl.WriteString("  tags = [")
		for i, tag := range svc.Tags {
			if i > 0 {
				hcl.WriteString(", ")
			}
			hcl.WriteString(fmt.Sprintf("\"%s\"", tag))
		}
		hcl.WriteString("]\n")
	}

	if len(svc.Meta) > 0 {
		hcl.WriteString("  meta = {\n")
		for key, value := range svc.Meta {
			hcl.WriteString(fmt.Sprintf("    \"%s\" = \"%s\"\n", key, value))
		}
		hcl.WriteString("  }\n")
	}

	// Health checks
	for _, check := range svc.Checks {
		hcl.WriteString("  check {\n")
		if check.ID != "" {
			hcl.WriteString(fmt.Sprintf("    id       = \"%s\"\n", check.ID))
		}
		if check.Name != "" {
			hcl.WriteString(fmt.Sprintf("    name     = \"%s\"\n", check.Name))
		}

		switch check.Type {
		case "http", "https":
			hcl.WriteString(fmt.Sprintf("    http     = \"%s\"\n", check.Endpoint))
		case "tcp":
			hcl.WriteString(fmt.Sprintf("    tcp      = \"%s\"\n", check.Endpoint))
		case "grpc":
			hcl.WriteString(fmt.Sprintf("    grpc     = \"%s\"\n", check.Endpoint))
		}

		if check.Interval != "" {
			hcl.WriteString(fmt.Sprintf("    interval = \"%s\"\n", check.Interval))
		}
		if check.Timeout != "" {
			hcl.WriteString(fmt.Sprintf("    timeout  = \"%s\"\n", check.Timeout))
		}

		hcl.WriteString("  }\n")
	}

	hcl.WriteString("}\n")

	return hcl.String()
}
