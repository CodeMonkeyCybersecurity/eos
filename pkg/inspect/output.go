package inspect

import (
	"fmt"
	"os"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

// WriteYAML writes infrastructure data to a YAML file
func WriteYAML(infrastructure *Infrastructure, outputPath string) error {
	// Create a comprehensive YAML structure with metadata
	yamlData := map[string]interface{}{
		"# Infrastructure Audit Report": nil,
		"# Generated by Eos Infrastructure Inspector": nil,
		"# " + time.Now().Format("2006-01-02 15:04:05 MST"): nil,
		"metadata": map[string]interface{}{
			"generated_at": infrastructure.Timestamp.Format(time.RFC3339),
			"hostname":     infrastructure.Hostname,
			"audit_type":   "infrastructure",
			"format":       "yaml",
			"version":      "1.0",
		},
		"system":    infrastructure.System,
		"docker":    infrastructure.Docker,
		"kvm":       infrastructure.KVM,
		"hetzner":   infrastructure.Hetzner,
		"services":  infrastructure.Services,
	}

	// Remove nil sections
	if infrastructure.Docker == nil {
		delete(yamlData, "docker")
	}
	if infrastructure.KVM == nil {
		delete(yamlData, "kvm")
	}
	if infrastructure.Hetzner == nil {
		delete(yamlData, "hetzner")
	}
	if infrastructure.Services == nil {
		delete(yamlData, "services")
	}

	// Marshal to YAML
	yamlContent, err := yaml.Marshal(yamlData)
	if err != nil {
		return fmt.Errorf("failed to marshal YAML: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf(`# Infrastructure Audit Report
# Generated by Eos Infrastructure Inspector
# Hostname: %s
# Date: %s
# Format: YAML
#
# This file contains a comprehensive audit of the infrastructure
# including system information, containers, virtual machines,
# cloud resources, and service configurations.
#
---
`, infrastructure.Hostname, infrastructure.Timestamp.Format("2006-01-02 15:04:05 MST"))

	// Combine header and content
	finalContent := header + string(yamlContent)

	// Write to file
	if err := os.WriteFile(outputPath, []byte(finalContent), 0644); err != nil {
		return fmt.Errorf("failed to write YAML file: %w", err)
	}

	return nil
}

// WriteTerraform writes infrastructure data as Terraform configuration
func WriteTerraform(infrastructure *Infrastructure, outputPath string) error {
	var tf strings.Builder

	// Write header
	tf.WriteString(fmt.Sprintf(`# Infrastructure Configuration
# Generated by Eos Infrastructure Inspector
# Hostname: %s
# Date: %s
# Format: Terraform HCL
#
# This file contains Terraform resources derived from the current
# infrastructure state. Review and modify as needed before applying.

terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
    hcloud = {
      source  = "hetznercloud/hcloud"
      version = "~> 1.0"
    }
    libvirt = {
      source  = "dmacvicar/libvirt"
      version = "~> 0.7"
    }
  }
}

`, infrastructure.Hostname, infrastructure.Timestamp.Format("2006-01-02 15:04:05 MST")))

	// Write Docker resources
	if infrastructure.Docker != nil {
		tf.WriteString(generateDockerTerraform(infrastructure.Docker))
	}

	// Write Hetzner resources
	if infrastructure.Hetzner != nil {
		tf.WriteString(generateHetznerTerraform(infrastructure.Hetzner))
	}

	// Write KVM resources
	if infrastructure.KVM != nil {
		tf.WriteString(generateKVMTerraform(infrastructure.KVM))
	}

	// Write locals block with system information
	tf.WriteString(generateSystemLocals(infrastructure.System))

	// Write to file
	if err := os.WriteFile(outputPath, []byte(tf.String()), 0644); err != nil {
		return fmt.Errorf("failed to write Terraform file: %w", err)
	}

	return nil
}

// generateDockerTerraform generates Terraform for Docker resources
func generateDockerTerraform(docker *DockerInfo) string {
	var tf strings.Builder

	tf.WriteString(`
# Docker Resources
# Note: Review and adjust these configurations before applying

`)

	// Generate container resources
	for _, container := range docker.Containers {
		if container.State != "running" {
			continue // Skip stopped containers
		}

		resourceName := sanitizeTerraformName(container.Name)
		tf.WriteString(fmt.Sprintf(`resource "docker_container" "%s" {
  name  = "%s"
  image = "%s"
  
  # Current status: %s
  restart = "%s"
  
`, resourceName, container.Name, container.Image, container.Status, container.Restart))

		// Add ports
		if len(container.Ports) > 0 {
			for _, port := range container.Ports {
				// Parse port mapping (e.g., "0.0.0.0:8080->80/tcp")
				if parts := strings.Split(port, "->"); len(parts) == 2 {
					hostPart := parts[0]
					containerPart := parts[1]
					
					// Extract port numbers
					if hostParts := strings.Split(hostPart, ":"); len(hostParts) == 2 {
						hostPort := hostParts[1]
						containerPort := strings.Split(containerPart, "/")[0]
						
						tf.WriteString(fmt.Sprintf(`  ports {
    internal = %s
    external = %s
  }
`, containerPort, hostPort))
					}
				}
			}
		}

		// Add environment variables (excluding sensitive ones)
		if len(container.Environment) > 0 {
			tf.WriteString("  env = [\n")
			for key, value := range container.Environment {
				if value != "***" { // Skip redacted values
					tf.WriteString(fmt.Sprintf(`    "%s=%s",
`, key, value))
				}
			}
			tf.WriteString("  ]\n")
		}

		// Add volumes
		if len(container.Volumes) > 0 {
			for _, volume := range container.Volumes {
				// Parse volume (e.g., "/host/path:/container/path:ro")
				parts := strings.Split(volume, ":")
				if len(parts) >= 2 {
					tf.WriteString(fmt.Sprintf(`  volumes {
    host_path      = "%s"
    container_path = "%s"
`, parts[0], parts[1]))
					if len(parts) > 2 {
						tf.WriteString(fmt.Sprintf(`    read_only      = %t
`, parts[2] == "ro"))
					}
					tf.WriteString("  }\n")
				}
			}
		}

		// Add networks
		if len(container.Networks) > 0 {
			tf.WriteString("  networks_advanced {\n")
			for _, network := range container.Networks {
				if network != "bridge" { // Skip default bridge
					tf.WriteString(fmt.Sprintf(`    name = "%s"
`, network))
				}
			}
			tf.WriteString("  }\n")
		}

		tf.WriteString("}\n\n")
	}

	// Generate network resources
	for _, network := range docker.Networks {
		if network.Name == "bridge" || network.Name == "host" || network.Name == "none" {
			continue // Skip default networks
		}

		resourceName := sanitizeTerraformName(network.Name)
		tf.WriteString(fmt.Sprintf(`resource "docker_network" "%s" {
  name   = "%s"
  driver = "%s"
  
  # Scope: %s
`, resourceName, network.Name, network.Driver, network.Scope))

		// Add labels
		if len(network.Labels) > 0 {
			tf.WriteString("  labels {\n")
			for key, value := range network.Labels {
				tf.WriteString(fmt.Sprintf(`    label = "%s=%s"
`, key, value))
			}
			tf.WriteString("  }\n")
		}

		tf.WriteString("}\n\n")
	}

	// Generate volume resources
	for _, volume := range docker.Volumes {
		resourceName := sanitizeTerraformName(volume.Name)
		tf.WriteString(fmt.Sprintf(`resource "docker_volume" "%s" {
  name   = "%s"
  driver = "%s"
`, resourceName, volume.Name, volume.Driver))

		// Add labels
		if len(volume.Labels) > 0 {
			tf.WriteString("  labels {\n")
			for key, value := range volume.Labels {
				tf.WriteString(fmt.Sprintf(`    label = "%s=%s"
`, key, value))
			}
			tf.WriteString("  }\n")
		}

		tf.WriteString("}\n\n")
	}

	return tf.String()
}

// generateHetznerTerraform generates Terraform for Hetzner resources
func generateHetznerTerraform(hetzner *HetznerInfo) string {
	var tf strings.Builder

	tf.WriteString(`
# Hetzner Cloud Resources
# Note: These resources represent the current state. 
# Review and adjust before applying.

`)

	// Generate server resources
	for _, server := range hetzner.Servers {
		resourceName := sanitizeTerraformName(server.Name)
		tf.WriteString(fmt.Sprintf(`resource "hcloud_server" "%s" {
  name        = "%s"
  server_type = "%s"
  image       = "%s"
  location    = "%s"
  
  # Current status: %s
  # Datacenter: %s
  # Public IP: %s
`, resourceName, server.Name, server.ServerType, server.Image, 
		server.Location, server.Status, server.Datacenter, server.PublicIP))

		// Add labels
		if len(server.Labels) > 0 {
			tf.WriteString("  labels = {\n")
			for key, value := range server.Labels {
				tf.WriteString(fmt.Sprintf(`    %s = "%s"
`, key, value))
			}
			tf.WriteString("  }\n")
		}

		tf.WriteString("}\n\n")
	}

	// Generate network resources
	for _, network := range hetzner.Networks {
		resourceName := sanitizeTerraformName(network.Name)
		tf.WriteString(fmt.Sprintf(`resource "hcloud_network" "%s" {
  name     = "%s"
  ip_range = "%s"
`, resourceName, network.Name, network.IPRange))

		// Add labels
		if len(network.Labels) > 0 {
			tf.WriteString("  labels = {\n")
			for key, value := range network.Labels {
				tf.WriteString(fmt.Sprintf(`    %s = "%s"
`, key, value))
			}
			tf.WriteString("  }\n")
		}

		tf.WriteString("}\n\n")

		// Generate subnet resources
		for idx, subnet := range network.Subnets {
			subnetResourceName := fmt.Sprintf("%s_subnet_%d", resourceName, idx)
			tf.WriteString(fmt.Sprintf(`resource "hcloud_network_subnet" "%s" {
  network_id   = hcloud_network.%s.id
  type         = "%s"
  network_zone = "%s"
  ip_range     = "%s"
}

`, subnetResourceName, resourceName, subnet.Type, subnet.NetworkZone, subnet.IPRange))
		}
	}

	// Generate firewall resources
	for _, firewall := range hetzner.Firewalls {
		resourceName := sanitizeTerraformName(firewall.Name)
		tf.WriteString(fmt.Sprintf(`resource "hcloud_firewall" "%s" {
  name = "%s"
  
`, resourceName, firewall.Name))

		// Add rules
		for _, rule := range firewall.Rules {
			tf.WriteString(fmt.Sprintf(`  rule {
    direction = "%s"
    protocol  = "%s"
`, rule.Direction, rule.Protocol))

			if rule.Port != "" {
				tf.WriteString(fmt.Sprintf(`    port      = "%s"
`, rule.Port))
			}

			if len(rule.SourceIPs) > 0 {
				tf.WriteString(`    source_ips = [
`)
				for _, ip := range rule.SourceIPs {
					tf.WriteString(fmt.Sprintf(`      "%s",
`, ip))
				}
				tf.WriteString("    ]\n")
			}

			tf.WriteString("  }\n")
		}

		// Add labels
		if len(firewall.Labels) > 0 {
			tf.WriteString("  labels = {\n")
			for key, value := range firewall.Labels {
				tf.WriteString(fmt.Sprintf(`    %s = "%s"
`, key, value))
			}
			tf.WriteString("  }\n")
		}

		tf.WriteString("}\n\n")
	}

	return tf.String()
}

// generateKVMTerraform generates Terraform for KVM resources
func generateKVMTerraform(kvm *KVMInfo) string {
	var tf strings.Builder

	tf.WriteString(`
# KVM/Libvirt Resources
# Note: These resources represent the current VM state.
# Review and adjust before applying.

provider "libvirt" {
  uri = "qemu:///system"
}

`)

	// Generate VM resources
	for _, vm := range kvm.VMs {
		if vm.State == "shut off" {
			continue // Skip stopped VMs
		}

		resourceName := sanitizeTerraformName(vm.Name)
		tf.WriteString(fmt.Sprintf(`resource "libvirt_domain" "%s" {
  name   = "%s"
  memory = "%s"
  vcpu   = %d
  
  # Current state: %s
  # UUID: %s
  # OS Type: %s
  
  autostart = true
`, resourceName, vm.Name, vm.Memory, vm.CPUs, vm.State, vm.UUID, vm.OSType))

		// Add disks
		for _, disk := range vm.Disks {
			tf.WriteString(fmt.Sprintf(`  
  disk {
    volume_id = "%s"  # %s
  }
`, disk.Path, disk.Device))
		}

		// Add network interfaces
		for _, intf := range vm.Interfaces {
			tf.WriteString(fmt.Sprintf(`  
  network_interface {
    network_name = "%s"
    mac          = "%s"
  }
`, intf.Source, intf.MAC))
		}

		tf.WriteString("}\n\n")
	}

	return tf.String()
}

// generateSystemLocals generates Terraform locals with system information
func generateSystemLocals(system *SystemInfo) string {
	var tf strings.Builder

	tf.WriteString(`
# System Information (for reference)
locals {
  system_info = {
    hostname     = "` + system.Hostname + `"
    os           = "` + system.OS + `"
    os_version   = "` + system.OSVersion + `"
    kernel       = "` + system.Kernel + `"
    architecture = "` + system.Architecture + `"
    uptime       = "` + system.Uptime + `"
    
    cpu = {
      model   = "` + system.CPU.Model + `"
      count   = ` + fmt.Sprintf("%d", system.CPU.Count) + `
      cores   = ` + fmt.Sprintf("%d", system.CPU.Cores) + `
      threads = ` + fmt.Sprintf("%d", system.CPU.Threads) + `
    }
    
    memory = {
      total     = "` + system.Memory.Total + `"
      used      = "` + system.Memory.Used + `"
      free      = "` + system.Memory.Free + `"
      available = "` + system.Memory.Available + `"
    }
  }
}

# Output system information for reference
output "system_info" {
  description = "Current system information"
  value       = local.system_info
}
`)

	return tf.String()
}

// sanitizeTerraformName converts a name to be Terraform-safe
func sanitizeTerraformName(name string) string {
	// Replace invalid characters with underscores
	result := strings.ReplaceAll(name, "-", "_")
	result = strings.ReplaceAll(result, ".", "_")
	result = strings.ReplaceAll(result, " ", "_")
	result = strings.ReplaceAll(result, "/", "_")
	result = strings.ReplaceAll(result, ":", "_")
	
	// Remove any remaining invalid characters
	var clean strings.Builder
	for _, r := range result {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_' {
			clean.WriteRune(r)
		}
	}
	
	result = clean.String()
	
	// Ensure it doesn't start with a number
	if len(result) > 0 && result[0] >= '0' && result[0] <= '9' {
		result = "resource_" + result
	}
	
	// Ensure it's not empty
	if result == "" {
		result = "unnamed_resource"
	}
	
	return result
}