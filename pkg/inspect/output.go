package inspect

import (
	"fmt"
	"os"
	"strings"
	"time"

	"context"

	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
	"gopkg.in/yaml.v3"
)

// WriteYAML writes infrastructure data to a YAML file
func WriteYAML(ctx context.Context, infrastructure *Infrastructure, outputPath string) error {
	start := time.Now()
	logger := otelzap.Ctx(ctx)

	logger.Info(" Starting YAML file generation",
		zap.String("output_path", outputPath),
		zap.String("hostname", infrastructure.Hostname),
		zap.Time("timestamp", infrastructure.Timestamp))
	// Create a comprehensive YAML structure with metadata
	yamlData := map[string]any{
		"# Infrastructure Audit Report":                     nil,
		"# Generated by Eos Infrastructure Inspector":       nil,
		"# " + time.Now().Format("2006-01-02 15:04:05 MST"): nil,
		"metadata": map[string]any{
			"generated_at": infrastructure.Timestamp.Format(time.RFC3339),
			"hostname":     infrastructure.Hostname,
			"audit_type":   "infrastructure",
			"format":       "yaml",
			"version":      "1.0",
		},
		"system":   infrastructure.System,
		"docker":   infrastructure.Docker,
		"kvm":      infrastructure.KVM,
		"hetzner":  infrastructure.Hetzner,
		"services": infrastructure.Services,
	}

	// Remove nil sections
	if infrastructure.Docker == nil {
		delete(yamlData, "docker")
	}
	if infrastructure.KVM == nil {
		delete(yamlData, "kvm")
	}
	if infrastructure.Hetzner == nil {
		delete(yamlData, "hetzner")
	}
	if infrastructure.Services == nil {
		delete(yamlData, "services")
	}

	// Marshal to YAML with logging
	logger.Info(" Marshaling infrastructure data to YAML",
		zap.Int("sections", len(yamlData)),
		zap.Bool("has_docker", infrastructure.Docker != nil),
		zap.Bool("has_kvm", infrastructure.KVM != nil),
		zap.Bool("has_hetzner", infrastructure.Hetzner != nil),
		zap.Bool("has_services", infrastructure.Services != nil))

	yamlContent, err := yaml.Marshal(yamlData)
	if err != nil {
		logger.Error(" Failed to marshal YAML data", zap.Error(err))
		return fmt.Errorf("failed to marshal YAML: %w", err)
	}

	logger.Info(" YAML marshaling completed", zap.Int("yaml_size_bytes", len(yamlContent)))

	// Add header comment
	header := fmt.Sprintf(`# Infrastructure Audit Report
# Generated by Eos Infrastructure Inspector
# Hostname: %s
# Date: %s
# Format: YAML
#
# This file contains a comprehensive audit of the infrastructure
# including system information, containers, virtual machines,
# cloud resources, and service configurations.
#
---
`, infrastructure.Hostname, infrastructure.Timestamp.Format("2006-01-02 15:04:05 MST"))

	// Combine header and content
	finalContent := header + string(yamlContent)

	// Write to file with comprehensive logging
	logger.Info(" Writing YAML file to disk",
		zap.String("file_path", outputPath),
		zap.Int("total_size_bytes", len(finalContent)),
		zap.String("permissions", "0644"))

	if err := os.WriteFile(outputPath, []byte(finalContent), 0644); err != nil {
		logger.Error(" Failed to write YAML file",
			zap.Error(err),
			zap.String("file_path", outputPath))
		return fmt.Errorf("failed to write YAML file: %w", err)
	}

	// Verify file was created successfully
	if fileInfo, err := os.Stat(outputPath); err == nil {
		logger.Info(" YAML file created successfully",
			zap.String("file_path", outputPath),
			zap.Int64("file_size_bytes", fileInfo.Size()),
			zap.String("file_mode", fileInfo.Mode().String()),
			zap.Duration("total_duration", time.Since(start)))
	} else {
		logger.Warn("Could not verify YAML file creation",
			zap.Error(err),
			zap.String("file_path", outputPath))
	}

	return nil
}

// WriteTerraform writes infrastructure data as modular Terraform configuration
func WriteTerraform(ctx context.Context, infrastructure *Infrastructure, outputPath string) error {
	// For backward compatibility, if outputPath is a file, create the old monolithic format
	if strings.HasSuffix(outputPath, ".tf") {
		return WriteTerraformMonolithic(ctx, infrastructure, outputPath)
	}

	// Otherwise, create modular structure
	return WriteTerraformModular(ctx, infrastructure, outputPath)
}

// WriteTerraformMonolithic writes infrastructure data as single Terraform file (legacy)
func WriteTerraformMonolithic(ctx context.Context, infrastructure *Infrastructure, outputPath string) error {
	start := time.Now()
	logger := otelzap.Ctx(ctx)

	logger.Info(" Starting Terraform configuration generation",
		zap.String("output_path", outputPath),
		zap.String("hostname", infrastructure.Hostname),
		zap.Time("timestamp", infrastructure.Timestamp))
	var tf strings.Builder

	// Write header with improved provider configuration
	tf.WriteString(fmt.Sprintf(`# Infrastructure Configuration
# Generated by Eos Infrastructure Inspector
# Hostname: %s
# Date: %s
# Format: Terraform HCL
#
# This file contains Terraform resources derived from the current
# infrastructure state. Review and modify as needed before applying.
#
# IMPORTANT: This is a reverse-engineered configuration. Before applying:
# 1. Review all resource configurations
# 2. Import existing resources using 'terraform import'
# 3. Test in a development environment first
# 4. Consider using modules for better organization

terraform {
  required_version = ">= 1.0"
  
  # Uncomment and configure backend for state management
  # backend "local" {
  #   path = "terraform.tfstate"
  # }
  
  required_providers {`, infrastructure.Hostname, infrastructure.Timestamp.Format("2006-01-02 15:04:05 MST")))

	// Only include providers for resources we actually have
	if infrastructure.Docker != nil && (len(infrastructure.Docker.Containers) > 0 || len(infrastructure.Docker.Networks) > 0 || len(infrastructure.Docker.Volumes) > 0) {
		tf.WriteString(`
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }`)
	}

	if infrastructure.Hetzner != nil && (len(infrastructure.Hetzner.Servers) > 0 || len(infrastructure.Hetzner.Networks) > 0) {
		tf.WriteString(`
    hcloud = {
      source  = "hetznercloud/hcloud"
      version = "~> 1.0"
    }`)
	}

	if infrastructure.KVM != nil && len(infrastructure.KVM.VMs) > 0 {
		tf.WriteString(`
    libvirt = {
      source  = "dmacvicar/libvirt"
      version = "~> 0.7"
    }`)
	}

	tf.WriteString(`
  }
}

# Variables for configuration management
variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
  default     = "dev"
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}

variable "enable_monitoring" {
  description = "Enable monitoring and logging for containers"
  type        = bool
  default     = true
}

variable "container_ports" {
  description = "Port mappings for containers"
  type = map(object({
    internal = number
    external = number
    protocol = string
  }))
  default = {}
  
  validation {
    condition = alltrue([
      for k, v in var.container_ports : 
      v.external >= 1024 && v.external <= 65535
    ])
    error_message = "External ports must be between 1024 and 65535."
  }
}

# Local values for computed configurations
locals {
  container_prefix = var.environment == "prod" ? "prod" : "dev"
  common_labels = {
    environment  = var.environment
    managed_by   = "terraform"
    generated_by = "eos-inspector"
    hostname     = "` + infrastructure.Hostname + `"
  }
}

`)

	// Write Docker resources with modular approach and logging
	if infrastructure.Docker != nil {
		logger.Info(" Generating Docker Terraform resources",
			zap.Int("containers", len(infrastructure.Docker.Containers)),
			zap.Int("networks", len(infrastructure.Docker.Networks)),
			zap.Int("volumes", len(infrastructure.Docker.Volumes)))

		dockerStart := time.Now()
		tf.WriteString(generateDockerTerraform(infrastructure.Docker))
		logger.Info(" Docker resources generated",
			zap.Duration("duration", time.Since(dockerStart)))

		// Generate separate module for Wazuh volumes if detected
		if hasWazuhVolumes(infrastructure.Docker) {
			logger.Info(" Generating Wazuh module configuration")
			tf.WriteString(generateWazuhModule(infrastructure.Docker))
		}
	}

	// Write Hetzner resources with logging
	if infrastructure.Hetzner != nil {
		logger.Info("☁️ Generating Hetzner Cloud Terraform resources",
			zap.Int("servers", len(infrastructure.Hetzner.Servers)),
			zap.Int("networks", len(infrastructure.Hetzner.Networks)),
			zap.Int("firewalls", len(infrastructure.Hetzner.Firewalls)),
			zap.Int("volumes", len(infrastructure.Hetzner.Volumes)))

		hetznerStart := time.Now()
		tf.WriteString(generateHetznerTerraform(infrastructure.Hetzner))
		logger.Info(" Hetzner resources generated",
			zap.Duration("duration", time.Since(hetznerStart)))
	}

	// Write KVM resources with logging
	if infrastructure.KVM != nil {
		logger.Info("🖥️ Generating KVM/Libvirt Terraform resources",
			zap.Int("vms", len(infrastructure.KVM.VMs)),
			zap.Int("networks", len(infrastructure.KVM.Networks)),
			zap.Int("storage_pools", len(infrastructure.KVM.StoragePools)))

		kvmStart := time.Now()
		tf.WriteString(generateKVMTerraform(infrastructure.KVM))
		logger.Info(" KVM resources generated",
			zap.Duration("duration", time.Since(kvmStart)))
	}

	// Write locals block with system information
	logger.Info(" Generating system information locals")
	tf.WriteString(generateSystemLocals(infrastructure.System))

	// Add migration and usage guidance with import command counting
	logger.Info(" Generating migration guide and import commands")
	migrationGuide := generateMigrationGuide(infrastructure)
	tf.WriteString(migrationGuide)

	// Count import commands for user feedback
	importCount := strings.Count(migrationGuide, "terraform import")
	logger.Info(" Migration guide generated", zap.Int("import_commands", importCount))

	// Write to file with comprehensive logging
	finalContent := tf.String()
	logger.Info(" Writing Terraform file to disk",
		zap.String("file_path", outputPath),
		zap.Int("total_size_bytes", len(finalContent)),
		zap.String("permissions", "0644"))

	if err := os.WriteFile(outputPath, []byte(finalContent), 0644); err != nil {
		logger.Error(" Failed to write Terraform file",
			zap.Error(err),
			zap.String("file_path", outputPath))
		return fmt.Errorf("failed to write Terraform file: %w", err)
	}

	// Verify file was created successfully and gather statistics
	if fileInfo, err := os.Stat(outputPath); err == nil {
		// Count different resource types in the generated content
		resourceCount := strings.Count(finalContent, "resource ")
		moduleCount := strings.Count(finalContent, "module ")
		variableCount := strings.Count(finalContent, "variable ")
		outputCount := strings.Count(finalContent, "output ")

		logger.Info(" Terraform file created successfully",
			zap.String("file_path", outputPath),
			zap.Int64("file_size_bytes", fileInfo.Size()),
			zap.String("file_mode", fileInfo.Mode().String()),
			zap.Int("total_resources", resourceCount),
			zap.Int("modules", moduleCount),
			zap.Int("variables", variableCount),
			zap.Int("outputs", outputCount),
			zap.Duration("total_duration", time.Since(start)))
	} else {
		logger.Warn("Could not verify Terraform file creation",
			zap.Error(err),
			zap.String("file_path", outputPath))
	}

	return nil
}

// WriteTerraformModular creates a modular Terraform configuration structure
func WriteTerraformModular(ctx context.Context, infrastructure *Infrastructure, baseDir string) error {
	start := time.Now()
	logger := otelzap.Ctx(ctx)

	logger.Info(" Starting modular Terraform configuration generation",
		zap.String("base_directory", baseDir),
		zap.String("hostname", infrastructure.Hostname),
		zap.Time("timestamp", infrastructure.Timestamp))

	// Create directory structure
	if err := createTerraformDirectories(baseDir); err != nil {
		return fmt.Errorf("failed to create directories: %w", err)
	}

	// Generate configuration files
	config := &TerraformConfig{
		Infrastructure: infrastructure,
		BaseDir:        baseDir,
		Logger:         logger.Logger(), // Get the underlying zap.Logger
	}

	// Generate core files
	if err := config.generateMainTf(); err != nil {
		return fmt.Errorf("failed to generate main.tf: %w", err)
	}

	if err := config.generateVariablesTf(); err != nil {
		return fmt.Errorf("failed to generate variables.tf: %w", err)
	}

	if err := config.generateOutputsTf(); err != nil {
		return fmt.Errorf("failed to generate outputs.tf: %w", err)
	}

	// Generate resource files
	if infrastructure.Docker != nil {
		if err := config.generateDockerResources(); err != nil {
			return fmt.Errorf("failed to generate docker resources: %w", err)
		}
	}

	if infrastructure.Hetzner != nil {
		if err := config.generateHetznerResources(); err != nil {
			return fmt.Errorf("failed to generate hetzner resources: %w", err)
		}
	}

	if infrastructure.KVM != nil {
		if err := config.generateKVMResources(); err != nil {
			return fmt.Errorf("failed to generate kvm resources: %w", err)
		}
	}

	// Generate modules
	if err := config.generateWazuhModule(); err != nil {
		return fmt.Errorf("failed to generate wazuh module: %w", err)
	}

	// Generate environment files
	if err := config.generateEnvironmentFiles(); err != nil {
		return fmt.Errorf("failed to generate environment files: %w", err)
	}

	// Generate documentation
	if err := config.generateDocumentation(); err != nil {
		return fmt.Errorf("failed to generate documentation: %w", err)
	}

	logger.Info(" Modular Terraform configuration created successfully",
		zap.String("base_directory", baseDir),
		zap.Duration("total_duration", time.Since(start)))

	return nil
}

// TerraformConfig holds configuration for generating modular Terraform
type TerraformConfig struct {
	Infrastructure *Infrastructure
	BaseDir        string
	Logger         *otelzap.Logger
}

// createTerraformDirectories creates the directory structure for modular Terraform
func createTerraformDirectories(baseDir string) error {
	dirs := []string{
		baseDir,
		baseDir + "/docker",
		baseDir + "/hetzner",
		baseDir + "/kvm",
		baseDir + "/modules",
		baseDir + "/modules/wazuh-volumes",
		baseDir + "/envs",
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	return nil
}

// generateDockerTerraform generates Terraform for Docker resources
func generateDockerTerraform(docker *DockerInfo) string {
	var tf strings.Builder

	tf.WriteString(`
# Docker Resources
# Note: Review and adjust these configurations before applying

`)

	// Generate container resources
	for _, container := range docker.Containers {
		if container.State != "running" {
			continue // Skip stopped containers
		}

		resourceName := sanitizeTerraformName(container.Name)
		tf.WriteString(fmt.Sprintf(`resource "docker_container" "%s" {
  name  = "${local.container_prefix}_%s"
  image = "%s"
  
  # Current status: %s
  restart = "%s"
  
  # Merge common labels with container-specific labels
  labels = merge(local.common_labels, {
    container_name = "%s"
    original_image = "%s"
  })
  
`, resourceName, container.Name, container.Image, container.Status, container.Restart, container.Name, container.Image))

		// Add ports with validation
		if len(container.Ports) > 0 {
			tf.WriteString("\n  # Port mappings\n")
			for _, port := range container.Ports {
				// Parse port mapping (e.g., "0.0.0.0:8080->80/tcp")
				if parts := strings.Split(port, "->"); len(parts) == 2 {
					hostPart := parts[0]
					containerPart := parts[1]

					// Extract port numbers
					if hostParts := strings.Split(hostPart, ":"); len(hostParts) == 2 {
						hostPort := hostParts[1]
						containerPort := strings.Split(containerPart, "/")[0]
						protocol := "tcp"
						if protocolParts := strings.Split(containerPart, "/"); len(protocolParts) == 2 {
							protocol = protocolParts[1]
						}

						tf.WriteString(fmt.Sprintf(`  ports {
    internal = %s
    external = %s
    protocol = "%s"
  }
`, containerPort, hostPort, protocol))
					}
				}
			}
		}

		// Add environment variables (excluding sensitive ones)
		if len(container.Environment) > 0 {
			tf.WriteString("  env = [\n")
			for key, value := range container.Environment {
				if value != "***" { // Skip redacted values
					tf.WriteString(fmt.Sprintf(`    "%s=%s",
`, key, value))
				}
			}
			tf.WriteString("  ]\n")
		}

		// Add volumes
		if len(container.Volumes) > 0 {
			for _, volume := range container.Volumes {
				// Parse volume (e.g., "/host/path:/container/path:ro")
				parts := strings.Split(volume, ":")
				if len(parts) >= 2 {
					tf.WriteString(fmt.Sprintf(`  volumes {
    host_path      = "%s"
    container_path = "%s"
`, parts[0], parts[1]))
					if len(parts) > 2 {
						tf.WriteString(fmt.Sprintf(`    read_only      = %t
`, parts[2] == "ro"))
					}
					tf.WriteString("  }\n")
				}
			}
		}

		// Add networks with proper resource references
		if len(container.Networks) > 0 {
			for _, network := range container.Networks {
				if network != "bridge" && network != "host" && network != "none" { // Skip default networks
					networkResourceName := sanitizeTerraformName(network)
					tf.WriteString(fmt.Sprintf(`  networks_advanced {
    name = docker_network.%s.name
  }
`, networkResourceName))
				}
			}
		}

		tf.WriteString("}\n\n")
	}

	// Generate network resources
	for _, network := range docker.Networks {
		if network.Name == "bridge" || network.Name == "host" || network.Name == "none" {
			continue // Skip default networks
		}

		resourceName := sanitizeTerraformName(network.Name)
		tf.WriteString(fmt.Sprintf(`resource "docker_network" "%s" {
  name   = "%s"
  driver = "%s"
  
  # Scope: %s
`, resourceName, network.Name, network.Driver, network.Scope))

		// Add labels with correct HCL syntax
		if len(network.Labels) > 0 {
			tf.WriteString("  labels = {\n")
			for key, value := range network.Labels {
				// Escape quotes in key and value
				safeKey := strings.ReplaceAll(key, `"`, `\"`)
				safeValue := strings.ReplaceAll(value, `"`, `\"`)
				tf.WriteString(fmt.Sprintf(`    "%s" = "%s"
`, safeKey, safeValue))
			}
			tf.WriteString("  }\n")
		}

		tf.WriteString("}\n\n")
	}

	// Generate volume resources
	for _, volume := range docker.Volumes {
		resourceName := sanitizeTerraformName(volume.Name)
		tf.WriteString(fmt.Sprintf(`resource "docker_volume" "%s" {
  name   = "%s"
  driver = "%s"
`, resourceName, volume.Name, volume.Driver))

		// Add labels with correct HCL syntax
		if len(volume.Labels) > 0 {
			tf.WriteString("  labels = {\n")
			for key, value := range volume.Labels {
				// Escape quotes in key and value
				safeKey := strings.ReplaceAll(key, `"`, `\"`)
				safeValue := strings.ReplaceAll(value, `"`, `\"`)
				tf.WriteString(fmt.Sprintf(`    "%s" = "%s"
`, safeKey, safeValue))
			}
			tf.WriteString("  }\n")
		}

		tf.WriteString("}\n\n")
	}

	return tf.String()
}

// generateHetznerTerraform generates Terraform for Hetzner resources
func generateHetznerTerraform(hetzner *HetznerInfo) string {
	var tf strings.Builder

	tf.WriteString(`
# Hetzner Cloud Resources
# Note: These resources represent the current state. 
# Review and adjust before applying.

`)

	// Generate server resources
	for _, server := range hetzner.Servers {
		resourceName := sanitizeTerraformName(server.Name)
		tf.WriteString(fmt.Sprintf(`resource "hcloud_server" "%s" {
  name        = "%s"
  server_type = "%s"
  image       = "%s"
  location    = "%s"
  
  # Current status: %s
  # Datacenter: %s
  # Public IP: %s
`, resourceName, server.Name, server.ServerType, server.Image,
			server.Location, server.Status, server.Datacenter, server.PublicIP))

		// Add labels
		if len(server.Labels) > 0 {
			tf.WriteString("  labels = {\n")
			for key, value := range server.Labels {
				tf.WriteString(fmt.Sprintf(`    %s = "%s"
`, key, value))
			}
			tf.WriteString("  }\n")
		}

		tf.WriteString("}\n\n")
	}

	// Generate network resources
	for _, network := range hetzner.Networks {
		resourceName := sanitizeTerraformName(network.Name)
		tf.WriteString(fmt.Sprintf(`resource "hcloud_network" "%s" {
  name     = "%s"
  ip_range = "%s"
`, resourceName, network.Name, network.IPRange))

		// Add labels
		if len(network.Labels) > 0 {
			tf.WriteString("  labels = {\n")
			for key, value := range network.Labels {
				tf.WriteString(fmt.Sprintf(`    %s = "%s"
`, key, value))
			}
			tf.WriteString("  }\n")
		}

		tf.WriteString("}\n\n")

		// Generate subnet resources
		for idx, subnet := range network.Subnets {
			subnetResourceName := fmt.Sprintf("%s_subnet_%d", resourceName, idx)
			tf.WriteString(fmt.Sprintf(`resource "hcloud_network_subnet" "%s" {
  network_id   = hcloud_network.%s.id
  type         = "%s"
  network_zone = "%s"
  ip_range     = "%s"
}

`, subnetResourceName, resourceName, subnet.Type, subnet.NetworkZone, subnet.IPRange))
		}
	}

	// Generate firewall resources
	for _, firewall := range hetzner.Firewalls {
		resourceName := sanitizeTerraformName(firewall.Name)
		tf.WriteString(fmt.Sprintf(`resource "hcloud_firewall" "%s" {
  name = "%s"
  
`, resourceName, firewall.Name))

		// Add rules
		for _, rule := range firewall.Rules {
			tf.WriteString(fmt.Sprintf(`  rule {
    direction = "%s"
    protocol  = "%s"
`, rule.Direction, rule.Protocol))

			if rule.Port != "" {
				tf.WriteString(fmt.Sprintf(`    port      = "%s"
`, rule.Port))
			}

			if len(rule.SourceIPs) > 0 {
				tf.WriteString(`    source_ips = [
`)
				for _, ip := range rule.SourceIPs {
					tf.WriteString(fmt.Sprintf(`      "%s",
`, ip))
				}
				tf.WriteString("    ]\n")
			}

			tf.WriteString("  }\n")
		}

		// Add labels
		if len(firewall.Labels) > 0 {
			tf.WriteString("  labels = {\n")
			for key, value := range firewall.Labels {
				tf.WriteString(fmt.Sprintf(`    %s = "%s"
`, key, value))
			}
			tf.WriteString("  }\n")
		}

		tf.WriteString("}\n\n")
	}

	return tf.String()
}

// generateKVMTerraform generates Terraform for KVM resources
func generateKVMTerraform(kvm *KVMInfo) string {
	var tf strings.Builder

	tf.WriteString(`
# KVM/Libvirt Resources
# Note: These resources represent the current VM state.
# Review and adjust before applying.

provider "libvirt" {
  uri = "qemu:///system"
}

`)

	// Generate VM resources
	for _, vm := range kvm.VMs {
		if vm.State == "shut off" {
			continue // Skip stopped VMs
		}

		resourceName := sanitizeTerraformName(vm.Name)
		tf.WriteString(fmt.Sprintf(`resource "libvirt_domain" "%s" {
  name   = "%s"
  memory = "%s"
  vcpu   = %d
  
  # Current state: %s
  # UUID: %s
  # OS Type: %s
  
  autostart = true
`, resourceName, vm.Name, vm.Memory, vm.CPUs, vm.State, vm.UUID, vm.OSType))

		// Add disks
		for _, disk := range vm.Disks {
			tf.WriteString(fmt.Sprintf(`  
  disk {
    volume_id = "%s"  # %s
  }
`, disk.Path, disk.Device))
		}

		// Add network interfaces
		for _, intf := range vm.Interfaces {
			tf.WriteString(fmt.Sprintf(`  
  network_interface {
    network_name = "%s"
    mac          = "%s"
  }
`, intf.Source, intf.MAC))
		}

		tf.WriteString("}\n\n")
	}

	return tf.String()
}

// generateSystemLocals generates Terraform locals with system information
func generateSystemLocals(system *SystemInfo) string {
	var tf strings.Builder

	tf.WriteString(`
# System Information (for reference)
locals {
  system_info = {
    hostname     = "` + system.Hostname + `"
    os           = "` + system.OS + `"
    os_version   = "` + system.OSVersion + `"
    kernel       = "` + system.Kernel + `"
    architecture = "` + system.Architecture + `"
    uptime       = "` + system.Uptime + `"
    
    cpu = {
      model   = "` + system.CPU.Model + `"
      count   = ` + fmt.Sprintf("%d", system.CPU.Count) + `
      cores   = ` + fmt.Sprintf("%d", system.CPU.Cores) + `
      threads = ` + fmt.Sprintf("%d", system.CPU.Threads) + `
    }
    
    memory = {
      total     = "` + system.Memory.Total + `"
      used      = "` + system.Memory.Used + `"
      free      = "` + system.Memory.Free + `"
      available = "` + system.Memory.Available + `"
    }
  }
}

# Output system information for reference
output "system_info" {
  description = "Current system information"
  value       = local.system_info
}
`)

	return tf.String()
}

// generateMigrationGuide generates migration and usage guidance
func generateMigrationGuide(infrastructure *Infrastructure) string {
	var tf strings.Builder

	tf.WriteString(`
#
# ================================================================================
# MIGRATION AND USAGE GUIDE
# ================================================================================
#
# This Terraform configuration was generated from existing infrastructure.
# Follow these steps to safely manage your infrastructure with Terraform:
#
# 1. REVIEW AND VALIDATE
#    - Review all resource configurations above
#    - Verify port mappings and network configurations
#    - Check labels and environment variables
#    - Ensure sensitive data is properly handled
#
# 2. INITIALIZE TERRAFORM
#    terraform init
#
# 3. IMPORT EXISTING RESOURCES
#    Before applying changes, import existing resources to avoid conflicts:
#
`)

	// Generate import commands for Docker resources
	if infrastructure.Docker != nil {
		tf.WriteString("# Docker resource imports:\n")

		for _, container := range infrastructure.Docker.Containers {
			if container.State == "running" {
				resourceName := sanitizeTerraformName(container.Name)
				tf.WriteString(fmt.Sprintf(`#    terraform import docker_container.%s %s
`, resourceName, container.Name))
			}
		}

		for _, network := range infrastructure.Docker.Networks {
			if network.Name != "bridge" && network.Name != "host" && network.Name != "none" {
				resourceName := sanitizeTerraformName(network.Name)
				tf.WriteString(fmt.Sprintf(`#    terraform import docker_network.%s %s
`, resourceName, network.Name))
			}
		}

		for _, volume := range infrastructure.Docker.Volumes {
			resourceName := sanitizeTerraformName(volume.Name)
			tf.WriteString(fmt.Sprintf(`#    terraform import docker_volume.%s %s
`, resourceName, volume.Name))
		}
	}

	tf.WriteString(`#
# 4. PLAN AND VERIFY
#    terraform plan
#    Review the plan output carefully - there should be minimal changes
#    if imports were successful
#
# 5. APPLY GRADUALLY
#    For production environments, consider applying changes incrementally:
#    terraform apply -target=docker_network.dev_network
#    terraform apply -target=docker_volume.specific_volume
#
# 6. ENVIRONMENT-SPECIFIC CONFIGURATIONS
#    Create environment-specific .tfvars files:
#
#    # dev.tfvars
#    environment = "dev"
#    enable_monitoring = true
#    container_ports = {
#      helen_dev = {
#        internal = 80
#        external = 8009
#        protocol = "tcp"
#      }
#    }
#
#    # prod.tfvars  
#    environment = "prod"
#    enable_monitoring = true
#    container_ports = {
#      helen_prod = {
#        internal = 80
#        external = 8080
#        protocol = "tcp"
#      }
#    }
#
# 7. USAGE
#    terraform apply -var-file="dev.tfvars"
#    terraform apply -var-file="prod.tfvars"
#
# ================================================================================
# IMPORTANT SECURITY NOTES
# ================================================================================
#
# - This configuration may contain sensitive information
# - Review all environment variables and remove secrets
# - Use Terraform's sensitive variables for secrets
# - Consider using external secret management (Vault, etc.)
# - Never commit sensitive data to version control
#
# ================================================================================
# RECOMMENDED NEXT STEPS
# ================================================================================
#
# 1. Split this monolithic file into smaller, focused files:
#    - main.tf (main resources)
#    - variables.tf (input variables)
#    - outputs.tf (output values)
#    - modules/ (reusable modules)
#
# 2. Add proper state management:
#    - Configure remote backend (S3, GCS, etc.)
#    - Enable state locking
#    - Set up workspace isolation
#
# 3. Implement CI/CD pipeline:
#    - Automated terraform plan on pull requests
#    - Automated terraform apply on main branch
#    - Integration with your existing CI/CD system
#
# 4. Add monitoring and alerting:
#    - Monitor infrastructure drift
#    - Set up alerts for resource changes
#    - Implement compliance checking
#
# Generated by Eos Infrastructure Inspector
# For more information: https://github.com/CodeMonkeyCybersecurity/eos
#
`)

	return tf.String()
}

// hasWazuhVolumes checks if there are Wazuh-related volumes
func hasWazuhVolumes(docker *DockerInfo) bool {
	for _, volume := range docker.Volumes {
		if strings.Contains(volume.Name, "wazuh") {
			return true
		}
	}
	return false
}

// generateWazuhModule generates a modular approach for Wazuh volumes
func generateWazuhModule(docker *DockerInfo) string {
	var tf strings.Builder

	tf.WriteString(`
# Wazuh Infrastructure Module
# This module manages Wazuh-related volumes in a modular way

module "wazuh_volumes" {
  source = "./modules/wazuh-volumes"
  
  environment = var.environment
  project     = "multi-node"
  volumes = {
`)

	// Extract Wazuh volume configurations
	for _, volume := range docker.Volumes {
		if strings.Contains(volume.Name, "wazuh") {
			// Extract volume type from name (e.g., "master-wazuh-logs" -> "logs")
			nameParts := strings.Split(volume.Name, "_")
			if len(nameParts) >= 2 {
				volumeType := strings.ReplaceAll(nameParts[len(nameParts)-1], "multi-node_", "")
				tf.WriteString(fmt.Sprintf(`    %s = {
      driver = "%s"
      labels = {
`, volumeType, volume.Driver))

				// Add labels
				for key, value := range volume.Labels {
					safeKey := strings.ReplaceAll(key, `"`, `\"`)
					safeValue := strings.ReplaceAll(value, `"`, `\"`)
					tf.WriteString(fmt.Sprintf(`        "%s" = "%s"
`, safeKey, safeValue))
				}

				tf.WriteString(`      }
    }
`)
			}
		}
	}

	tf.WriteString(`  }
}

# Module outputs for reference
output "wazuh_volume_names" {
  description = "Names of created Wazuh volumes"
  value       = module.wazuh_volumes.volume_names
}

`)

	return tf.String()
}

// sanitizeTerraformName converts a name to be Terraform-safe
func sanitizeTerraformName(name string) string {
	// Replace invalid characters with underscores
	result := strings.ReplaceAll(name, "-", "_")
	result = strings.ReplaceAll(result, ".", "_")
	result = strings.ReplaceAll(result, " ", "_")
	result = strings.ReplaceAll(result, "/", "_")
	result = strings.ReplaceAll(result, ":", "_")

	// Remove any remaining invalid characters
	var clean strings.Builder
	for _, r := range result {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_' {
			clean.WriteRune(r)
		}
	}

	result = clean.String()

	// Ensure it doesn't start with a number
	if len(result) > 0 && result[0] >= '0' && result[0] <= '9' {
		result = "resource_" + result
	}

	// Ensure it's not empty
	if result == "" {
		result = "unnamed_resource"
	}

	return result
}
