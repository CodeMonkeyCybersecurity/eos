package saltstack

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/execute"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

// BootstrapAPIConfig configures Salt with API-first approach and proper file_roots
func BootstrapAPIConfig(rc *eos_io.RuntimeContext, config *Config) error {
	logger := otelzap.Ctx(rc.Ctx)
	logger.Info("Bootstrapping Salt with API-first configuration")

	// 1. Configure master/minion files with proper file_roots
	if err := configureMasterWithFileRoots(rc, config); err != nil {
		return fmt.Errorf("failed to configure Salt master: %w", err)
	}

	// 2. Configure REST API with CherryPy
	if err := configureAPIService(rc, config); err != nil {
		return fmt.Errorf("failed to configure API service: %w", err)
	}

	// 3. Create API user with secure credentials
	apiCreds, err := createSecureAPIUser(rc)
	if err != nil {
		return fmt.Errorf("failed to create API user: %w", err)
	}

	// 4. Setup file_roots and symlinks
	if err := SetupFileRoots(rc); err != nil {
		return fmt.Errorf("failed to setup file_roots: %w", err)
	}

	// 5. Start services in correct order
	if err := startAPIServices(rc, config); err != nil {
		return fmt.Errorf("failed to start Salt services: %w", err)
	}

	// 6. Save API credentials for future use
	if err := saveAPICredentialsToFile(rc, apiCreds); err != nil {
		return fmt.Errorf("failed to save API credentials: %w", err)
	}

	logger.Info("Salt API bootstrap completed successfully",
		zap.String("api_url", "https://localhost:8000"),
		zap.String("api_user", apiCreds.Username))

	return nil
}

// configureMasterWithFileRoots sets up Salt master config with proper file_roots
func configureMasterWithFileRoots(rc *eos_io.RuntimeContext, config *Config) error {
	logger := otelzap.Ctx(rc.Ctx)
	logger.Info("Configuring Salt master with file_roots")

	// Create master config directory
	masterDir := "/etc/salt/master.d"
	if err := os.MkdirAll(masterDir, 0755); err != nil {
		return fmt.Errorf("failed to create master.d directory: %w", err)
	}

	// Master configuration with file_roots
	masterConfig := `# Eos Salt Master Configuration
# Auto-generated by eos - DO NOT EDIT MANUALLY

# File roots configuration for Eos states
file_roots:
  base:
    - /srv/salt
    - /srv/salt/eos
    - /opt/eos/salt/states

# Pillar roots
pillar_roots:
  base:
    - /srv/pillar
    - /opt/eos/salt/pillar

# Interface to bind to (0.0.0.0 for all interfaces)
interface: 0.0.0.0

# Worker threads
worker_threads: 5

# Job cache
keep_jobs: 24

# State output
state_output: mixed
state_verbose: True

# Security settings
permissive_pki_access: False
drop_messages_signature_fail: True

# Performance tuning
gather_job_timeout: 10
timeout: 30
`

	// Write master configuration
	masterConfigPath := filepath.Join(masterDir, "eos.conf")
	if err := os.WriteFile(masterConfigPath, []byte(masterConfig), 0644); err != nil {
		return fmt.Errorf("failed to write master config: %w", err)
	}

	// Minion configuration for masterless mode
	if !config.MasterMode {
		minionConfig := `# Eos Salt Minion Configuration (Masterless Mode)
# Auto-generated by eos - DO NOT EDIT MANUALLY

# Masterless mode
file_client: local

# File roots for masterless mode
file_roots:
  base:
    - /srv/salt
    - /srv/salt/eos
    - /opt/eos/salt/states

# Pillar roots for masterless mode
pillar_roots:
  base:
    - /srv/pillar
    - /opt/eos/salt/pillar

# State output
state_output: mixed
state_verbose: True

# Log level
log_level: %s
`
		minionConfigContent := fmt.Sprintf(minionConfig, config.LogLevel)
		minionConfigPath := "/etc/salt/minion.d/eos.conf"
		
		// Create minion.d directory
		minionDir := "/etc/salt/minion.d"
		if err := os.MkdirAll(minionDir, 0755); err != nil {
			return fmt.Errorf("failed to create minion.d directory: %w", err)
		}

		if err := os.WriteFile(minionConfigPath, []byte(minionConfigContent), 0644); err != nil {
			return fmt.Errorf("failed to write minion config: %w", err)
		}
	}

	logger.Info("Salt master and minion configuration completed")
	return nil
}

// configureAPIService sets up the Salt API service configuration
func configureAPIService(rc *eos_io.RuntimeContext, config *Config) error {
	logger := otelzap.Ctx(rc.Ctx)
	logger.Info("Configuring Salt REST API service")

	// API configuration
	apiConfig := `# Salt API Configuration
# Auto-generated by eos - DO NOT EDIT MANUALLY

rest_cherrypy:
  port: 8000
  ssl_crt: /etc/salt/pki/api/cert.pem
  ssl_key: /etc/salt/pki/api/key.pem
  debug: False
  disable_ssl: False
  webhook_disable_auth: False
  cors_origin: null
  # Allow both local and remote connections
  host: 0.0.0.0

# External authentication configuration
external_auth:
  pam:
    eos-api:
      - .*
      - '@wheel'
      - '@runner'
      - '@jobs'

# Netapi configuration
netapi_enable_clients:
  - local
  - local_async
  - local_batch
  - local_subset
  - runner
  - runner_async
  - wheel
  - wheel_async
`

	// Write API configuration
	apiConfigPath := "/etc/salt/master.d/api.conf"
	if err := os.WriteFile(apiConfigPath, []byte(apiConfig), 0644); err != nil {
		return fmt.Errorf("failed to write API config: %w", err)
	}

	// Generate SSL certificates for API
	if err := generateAPISSLCertificates(rc); err != nil {
		return fmt.Errorf("failed to generate API SSL certificates: %w", err)
	}

	logger.Info("Salt API configuration completed")
	return nil
}

// APICredentials holds the generated API credentials
type APICredentials struct {
	Username string
	Password string
	URL      string
}

// createSecureAPIUser creates a system user for API access with secure password
func createSecureAPIUser(rc *eos_io.RuntimeContext) (*APICredentials, error) {
	logger := otelzap.Ctx(rc.Ctx)
	
	username := "eos-api"
	password := generateAPIPassword()
	
	logger.Info("Creating API user", zap.String("username", username))

	// Check if user exists
	checkCmd := execute.Options{
		Command: "id",
		Args:    []string{username},
		Capture: true,
	}
	
	if _, err := execute.Run(rc.Ctx, checkCmd); err != nil {
		// User doesn't exist, create it
		createCmd := execute.Options{
			Command: "useradd",
			Args: []string{
				"-r",           // System user
				"-s", "/bin/false", // No shell
				"-d", "/nonexistent", // No home
				username,
			},
		}
		
		if _, err := execute.Run(rc.Ctx, createCmd); err != nil {
			return nil, fmt.Errorf("failed to create user: %w", err)
		}
	}

	// Set password using echo and pipe to chpasswd
	passwordInput := fmt.Sprintf("%s:%s", username, password)
	passwordCmd := execute.Options{
		Command: "bash",
		Args:    []string{"-c", fmt.Sprintf("echo '%s' | chpasswd", passwordInput)},
	}
	
	if _, err := execute.Run(rc.Ctx, passwordCmd); err != nil {
		return nil, fmt.Errorf("failed to set password: %w", err)
	}

	// Add user to salt group if it exists
	groupCmd := execute.Options{
		Command: "usermod",
		Args:    []string{"-a", "-G", "salt", username},
	}
	
	// Ignore error - salt group might not exist in masterless mode
	execute.Run(rc.Ctx, groupCmd)

	return &APICredentials{
		Username: username,
		Password: password,
		URL:      "https://localhost:8000",
	}, nil
}

// generateAPIPassword generates a cryptographically secure password for API
func generateAPIPassword() string {
	const passwordLength = 32
	b := make([]byte, passwordLength)
	if _, err := rand.Read(b); err != nil {
		// Fallback to timestamp-based password if crypto fails
		return fmt.Sprintf("eos-%d-%s", time.Now().Unix(), base64.URLEncoding.EncodeToString([]byte(time.Now().String())))
	}
	return base64.URLEncoding.EncodeToString(b)[:passwordLength]
}

// generateAPISSLCertificates creates self-signed SSL certificates for the API
func generateAPISSLCertificates(rc *eos_io.RuntimeContext) error {
	logger := otelzap.Ctx(rc.Ctx)
	logger.Info("Generating SSL certificates for Salt API")

	// Create PKI directory
	pkiDir := "/etc/salt/pki/api"
	if err := os.MkdirAll(pkiDir, 0755); err != nil {
		return fmt.Errorf("failed to create PKI directory: %w", err)
	}

	certPath := filepath.Join(pkiDir, "cert.pem")
	keyPath := filepath.Join(pkiDir, "key.pem")

	// Check if certificates already exist
	if _, err := os.Stat(certPath); err == nil {
		logger.Info("SSL certificates already exist, skipping generation")
		return nil
	}

	// Generate self-signed certificate
	opensslCmd := execute.Options{
		Command: "openssl",
		Args: []string{
			"req", "-x509", "-newkey", "rsa:4096",
			"-keyout", keyPath,
			"-out", certPath,
			"-days", "3650",
			"-nodes",
			"-subj", "/C=US/ST=State/L=City/O=Eos/CN=localhost",
		},
		Timeout: 30 * time.Second,
	}

	if _, err := execute.Run(rc.Ctx, opensslCmd); err != nil {
		return fmt.Errorf("failed to generate SSL certificate: %w", err)
	}

	// Set permissions
	if err := os.Chmod(keyPath, 0600); err != nil {
		return fmt.Errorf("failed to set key permissions: %w", err)
	}

	if err := os.Chmod(certPath, 0644); err != nil {
		return fmt.Errorf("failed to set cert permissions: %w", err)
	}

	logger.Info("SSL certificates generated successfully")
	return nil
}

// startAPIServices starts Salt services in the correct order for API bootstrap
func startAPIServices(rc *eos_io.RuntimeContext, config *Config) error {
	logger := otelzap.Ctx(rc.Ctx)
	
	services := []string{"salt-minion", "salt-api"}
	if config.MasterMode {
		services = []string{"salt-master", "salt-minion", "salt-api"}
	}

	for _, service := range services {
		logger.Info("Starting service", zap.String("service", service))
		
		// Enable service
		enableCmd := execute.Options{
			Command: "systemctl",
			Args:    []string{"enable", service},
		}
		execute.Run(rc.Ctx, enableCmd)

		// Start service
		startCmd := execute.Options{
			Command: "systemctl",
			Args:    []string{"restart", service},
		}
		
		if _, err := execute.Run(rc.Ctx, startCmd); err != nil {
			logger.Warn("Failed to start service", 
				zap.String("service", service),
				zap.Error(err))
			// Continue with other services
		}

		// Give service time to start
		time.Sleep(2 * time.Second)
	}

	// Verify API is responding
	time.Sleep(5 * time.Second)
	if err := verifyAPIResponsive(rc); err != nil {
		logger.Warn("API not yet responsive", zap.Error(err))
		// Not fatal - API might need more time
	}

	return nil
}

// verifyAPIResponsive checks if the API is responding
func verifyAPIResponsive(rc *eos_io.RuntimeContext) error {
	logger := otelzap.Ctx(rc.Ctx)
	
	// Simple curl test to API endpoint
	curlCmd := execute.Options{
		Command: "curl",
		Args: []string{
			"-k", // Ignore self-signed cert
			"-s",
			"-o", "/dev/null",
			"-w", "%{http_code}",
			"https://localhost:8000/",
		},
		Capture: true,
		Timeout: 5 * time.Second,
	}

	output, err := execute.Run(rc.Ctx, curlCmd)
	if err != nil {
		return fmt.Errorf("API not responding: %w", err)
	}

	httpCode := strings.TrimSpace(output)
	if httpCode != "401" && httpCode != "200" {
		return fmt.Errorf("unexpected HTTP code: %s", httpCode)
	}

	logger.Info("Salt API is responsive", zap.String("http_code", httpCode))
	return nil
}

// saveAPICredentialsToFile saves the API credentials for future use
func saveAPICredentialsToFile(rc *eos_io.RuntimeContext, creds *APICredentials) error {
	logger := otelzap.Ctx(rc.Ctx)
	
	// Create credentials directory
	credsDir := "/etc/eos/salt"
	if err := os.MkdirAll(credsDir, 0700); err != nil {
		return fmt.Errorf("failed to create credentials directory: %w", err)
	}

	// Write credentials file
	credsFile := filepath.Join(credsDir, "api.env")
	content := fmt.Sprintf(`# Salt API Credentials
# Auto-generated by eos - DO NOT SHARE
export SALT_API_URL="%s"
export SALT_API_USER="%s"
export SALT_API_PASSWORD="%s"
export SALT_API_EAUTH="pam"
`, creds.URL, creds.Username, creds.Password)

	if err := os.WriteFile(credsFile, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write credentials: %w", err)
	}

	// Also write to systemd environment file for services
	systemdEnvFile := "/etc/eos/salt/api.conf"
	systemdContent := fmt.Sprintf(`SALT_API_URL=%s
SALT_API_USER=%s
SALT_API_PASSWORD=%s
SALT_API_EAUTH=pam
`, creds.URL, creds.Username, creds.Password)

	if err := os.WriteFile(systemdEnvFile, []byte(systemdContent), 0600); err != nil {
		return fmt.Errorf("failed to write systemd env file: %w", err)
	}

	logger.Info("API credentials saved",
		zap.String("credentials_file", credsFile),
		zap.String("systemd_env_file", systemdEnvFile))

	// Display instructions
	logger.Info("terminal prompt: ===== Salt API Configuration Complete =====")
	logger.Info("terminal prompt: API URL: " + creds.URL)
	logger.Info("terminal prompt: API User: " + creds.Username)
	logger.Info("terminal prompt: ")
	logger.Info("terminal prompt: To use the API, source the credentials:")
	logger.Info("terminal prompt:   source /etc/eos/salt/api.env")
	logger.Info("terminal prompt: ")
	logger.Info("terminal prompt: Or set them in your environment:")
	logger.Info("terminal prompt:   export SALT_API_URL=" + creds.URL)
	logger.Info("terminal prompt:   export SALT_API_USER=" + creds.Username)
	logger.Info("terminal prompt:   export SALT_API_PASSWORD=<check /etc/eos/salt/api.env>")

	return nil
}

// LoadAPICredentials loads saved API credentials
func LoadAPICredentials() (*APICredentials, error) {
	credsFile := "/etc/eos/salt/api.env"
	
	content, err := os.ReadFile(credsFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read credentials: %w", err)
	}

	creds := &APICredentials{}
	lines := strings.Split(string(content), "\n")
	
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "export SALT_API_URL=") {
			creds.URL = strings.Trim(strings.TrimPrefix(line, "export SALT_API_URL="), "\"")
		} else if strings.HasPrefix(line, "export SALT_API_USER=") {
			creds.Username = strings.Trim(strings.TrimPrefix(line, "export SALT_API_USER="), "\"")
		} else if strings.HasPrefix(line, "export SALT_API_PASSWORD=") {
			creds.Password = strings.Trim(strings.TrimPrefix(line, "export SALT_API_PASSWORD="), "\"")
		}
	}

	if creds.URL == "" || creds.Username == "" || creds.Password == "" {
		return nil, fmt.Errorf("incomplete credentials in file")
	}

	return creds, nil
}