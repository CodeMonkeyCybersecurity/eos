// pkg/vault/config_builder.go
//
// Centralized Vault configuration builder with dynamic hostname discovery
// DRY principle: One source of truth for all Vault config generation

package vault

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

// VaultConfigBuilder builds Vault configuration with dynamic hostname resolution
type VaultConfigBuilder struct {
	rc       *eos_io.RuntimeContext
	hostname string // Dynamically discovered hostname

	// Paths (with defaults)
	ConfigDir string // /etc/vault.d
	DataDir   string // /opt/vault/data
	TLSDir    string // /etc/vault.d/tls

	// Ports
	APIPort     int // 8200
	ClusterPort int // 8201

	// TLS
	TLSCertFile string // /etc/vault.d/tls/vault.crt
	TLSKeyFile  string // /etc/vault.d/tls/vault.key

	// Storage backend
	StorageBackend string // "consul" or "raft"
	ConsulAddress  string // 127.0.0.1:8500

	// Logging
	LogLevel  string // "info"
	LogFormat string // "json"
}

// NewConfigBuilder creates a new Vault config builder with dynamic hostname discovery
func NewConfigBuilder(rc *eos_io.RuntimeContext) (*VaultConfigBuilder, error) {
	logger := otelzap.Ctx(rc.Ctx)

	// Dynamically discover hostname
	hostname, err := discoverHostname()
	if err != nil {
		return nil, fmt.Errorf("failed to discover hostname: %w", err)
	}

	logger.Info("Discovered hostname for Vault configuration",
		zap.String("hostname", hostname))

	return &VaultConfigBuilder{
		rc:             rc,
		hostname:       hostname,
		ConfigDir:      "/etc/vault.d",
		DataDir:        "/opt/vault/data",
		TLSDir:         "/etc/vault.d/tls",
		APIPort:        8200,
		ClusterPort:    8201,
		TLSCertFile:    "/etc/vault.d/tls/vault.crt",
		TLSKeyFile:     "/etc/vault.d/tls/vault.key",
		StorageBackend: "consul", // Default to Consul for HA
		ConsulAddress:  "127.0.0.1:8500",
		LogLevel:       "info",
		LogFormat:      "json",
	}, nil
}

// discoverHostname dynamically discovers the system hostname
// Priority:
//   1. VAULT_HOSTNAME environment variable (explicit override)
//   2. os.Hostname() (system hostname)
//   3. Fallback to "localhost" (last resort)
func discoverHostname() (string, error) {
	// Check environment variable first (allows override)
	if envHostname := os.Getenv("VAULT_HOSTNAME"); envHostname != "" {
		return envHostname, nil
	}

	// Get system hostname
	hostname, err := os.Hostname()
	if err != nil {
		return "", fmt.Errorf("failed to get system hostname: %w", err)
	}

	// Clean up hostname (remove domain if present, keep short name)
	hostname = strings.Split(hostname, ".")[0]

	if hostname == "" {
		return "localhost", nil // Fallback
	}

	return hostname, nil
}

// GetHostname returns the discovered hostname
func (vcb *VaultConfigBuilder) GetHostname() string {
	return vcb.hostname
}

// GetAPIAddr returns the full API address (https://hostname:8200)
func (vcb *VaultConfigBuilder) GetAPIAddr() string {
	return fmt.Sprintf("https://%s:%d", vcb.hostname, vcb.APIPort)
}

// GetClusterAddr returns the full cluster address (https://hostname:8201)
func (vcb *VaultConfigBuilder) GetClusterAddr() string {
	return fmt.Sprintf("https://%s:%d", vcb.hostname, vcb.ClusterPort)
}

// GetAPIAddrLocal returns the local API address for internal use (https://127.0.0.1:8200)
func (vcb *VaultConfigBuilder) GetAPIAddrLocal() string {
	return fmt.Sprintf("https://127.0.0.1:%d", vcb.APIPort)
}

// BuildServerConfig generates the vault.hcl configuration file content
func (vcb *VaultConfigBuilder) BuildServerConfig() string {
	logger := otelzap.Ctx(vcb.rc.Ctx)

	logger.Info("Building Vault server configuration",
		zap.String("hostname", vcb.hostname),
		zap.String("api_addr", vcb.GetAPIAddr()),
		zap.String("cluster_addr", vcb.GetClusterAddr()),
		zap.String("storage", vcb.StorageBackend))

	config := fmt.Sprintf(`# Vault Server Configuration
# Generated by Eos with dynamic hostname discovery
# Hostname: %s

`, vcb.hostname)

	// Storage backend
	switch vcb.StorageBackend {
	case "consul":
		config += fmt.Sprintf(`storage "consul" {
  address          = "%s"
  path             = "vault/"
  scheme           = "http"
  check_timeout    = "5s"
  consistency_mode = "strong"
}

service_registration "consul" {
  address = "%s"
}

`, vcb.ConsulAddress, vcb.ConsulAddress)
	case "raft":
		config += fmt.Sprintf(`storage "raft" {
  path    = "%s"
  node_id = "%s"
}

service_registration "consul" {
  address = "%s"
}

`, vcb.DataDir, vcb.hostname, vcb.ConsulAddress)
	}

	// Listener configuration
	config += fmt.Sprintf(`listener "tcp" {
  address       = "0.0.0.0:%d"
  tls_disable   = false
  tls_cert_file = "%s"
  tls_key_file  = "%s"
}

`, vcb.APIPort, vcb.TLSCertFile, vcb.TLSKeyFile)

	// CRITICAL: Use hostname for api_addr, not 127.0.0.1!
	// This fixes the web UI redirect issue
	config += fmt.Sprintf(`# CRITICAL: api_addr must use hostname, not 127.0.0.1
# This allows external access to web UI and API
api_addr     = "%s"
cluster_addr = "%s"

`, vcb.GetAPIAddr(), vcb.GetClusterAddr())

	// Additional settings
	config += fmt.Sprintf(`ui           = true
disable_mlock = false
log_level     = "%s"
log_format    = "%s"
`, vcb.LogLevel, vcb.LogFormat)

	return config
}

// WriteServerConfig writes the vault.hcl configuration file
func (vcb *VaultConfigBuilder) WriteServerConfig() error {
	logger := otelzap.Ctx(vcb.rc.Ctx)

	configPath := filepath.Join(vcb.ConfigDir, "vault.hcl")
	config := vcb.BuildServerConfig()

	// Create backup of existing config
	if _, err := os.Stat(configPath); err == nil {
		backupPath := configPath + ".backup." + fmt.Sprint(os.Getpid())
		if err := os.Rename(configPath, backupPath); err != nil {
			logger.Warn("Failed to backup existing config", zap.Error(err))
		} else {
			logger.Info("Backed up existing config", zap.String("backup", backupPath))
		}
	}

	// Ensure directory exists
	if err := os.MkdirAll(vcb.ConfigDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Write new config
	if err := os.WriteFile(configPath, []byte(config), 0640); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	logger.Info("Vault configuration written successfully",
		zap.String("path", configPath),
		zap.String("hostname", vcb.hostname),
		zap.String("api_addr", vcb.GetAPIAddr()))

	return nil
}

// BuildAgentConfig generates the vault-agent-eos.hcl configuration
func (vcb *VaultConfigBuilder) BuildAgentConfig(roleID, secretIDPath, tokenPath string) string {
	return fmt.Sprintf(`# Vault Agent Configuration
# Generated by Eos with dynamic hostname discovery
# Hostname: %s

vault {
  address = "%s"
}

auto_auth {
  method {
    type = "approle"
    config = {
      role_id_file_path                   = "%s"
      secret_id_file_path                 = "%s"
      remove_secret_id_file_after_reading = false
    }
  }

  sink {
    type = "file"
    config = {
      path = "%s"
      mode = 0640
    }
  }
}
`, vcb.hostname, vcb.GetAPIAddr(), roleID, secretIDPath, tokenPath)
}

// ExportEnvironmentVars returns environment variables for Vault client configuration
func (vcb *VaultConfigBuilder) ExportEnvironmentVars() map[string]string {
	return map[string]string{
		"VAULT_ADDR":        vcb.GetAPIAddr(),
		"VAULT_SKIP_VERIFY": "1", // For self-signed certificates
	}
}

// GetEnvironmentVarsString returns environment variables as export statements
func (vcb *VaultConfigBuilder) GetEnvironmentVarsString() string {
	vars := vcb.ExportEnvironmentVars()
	result := ""
	for k, v := range vars {
		result += fmt.Sprintf("export %s=\"%s\"\n", k, v)
	}
	return result
}
