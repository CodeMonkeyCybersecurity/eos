// pkg/enrollment/inventory.go
package enrollment

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
	
	// Database drivers
	_ "github.com/lib/pq"
)

// ExportToEosInventory exports system information to eos inventory
func ExportToEosInventory(rc *eos_io.RuntimeContext, info *SystemInfo) error {
	logger := otelzap.Ctx(rc.Ctx)
	
	logger.Info("Exporting system information to eos inventory")
	
	// Generate Salt pillar data
	if err := generateSaltPillarData(rc, info); err != nil {
		return fmt.Errorf("failed to generate Salt pillar data: %w", err)
	}
	
	// Generate system facts
	if err := generateSystemFacts(rc, info); err != nil {
		return fmt.Errorf("failed to generate system facts: %w", err)
	}
	
	// Export to inventory database
	if err := exportToInventoryDatabase(rc, info); err != nil {
		logger.Warn("Failed to export to inventory database", zap.Error(err))
		// Continue - this is not critical
	}
	
	// Generate Terraform data
	if err := generateTerraformData(rc, info); err != nil {
		logger.Warn("Failed to generate Terraform data", zap.Error(err))
		// Continue - this is not critical
	}
	
	logger.Info("System information exported successfully")
	return nil
}

// generateSaltPillarData generates Salt pillar data with system facts
func generateSaltPillarData(rc *eos_io.RuntimeContext, info *SystemInfo) error {
	logger := otelzap.Ctx(rc.Ctx)
	
	// Check if we're in dry-run mode
	if rc.Attributes != nil {
		if dryRun, exists := rc.Attributes["dry_run"]; exists && dryRun == "true" {
			logger.Info("DRY RUN: Would generate Salt pillar data")
			return nil
		}
	}
	
	// Create pillar directory structure
	pillarDir := "/srv/pillar"
	nodesDir := filepath.Join(pillarDir, "nodes")
	
	if err := os.MkdirAll(nodesDir, 0755); err != nil {
		return fmt.Errorf("failed to create pillar directory: %w", err)
	}
	
	// Generate node-specific pillar
	hostname := strings.ToLower(info.Hostname)
	if strings.Contains(hostname, ".") {
		hostname = strings.Split(hostname, ".")[0] // Remove domain
	}
	
	pillarPath := filepath.Join(nodesDir, fmt.Sprintf("%s.sls", hostname))
	
	pillarData := generateNodePillar(info)
	
	if err := os.WriteFile(pillarPath, []byte(pillarData), 0644); err != nil {
		return fmt.Errorf("failed to write pillar file: %w", err)
	}
	
	// Update top.sls to include this node
	if err := updateTopSLS(rc, hostname, pillarDir); err != nil {
		logger.Warn("Failed to update top.sls", zap.Error(err))
	}
	
	logger.Info("Salt pillar data generated", zap.String("pillar_path", pillarPath))
	return nil
}

// generateNodePillar generates pillar data for a specific node
func generateNodePillar(info *SystemInfo) string {
	var pillar strings.Builder
	
	// Header
	pillar.WriteString("# Salt pillar data for node: " + info.Hostname + "\n")
	pillar.WriteString("# Generated by: eos self enroll\n")
	pillar.WriteString("# Generated at: " + time.Now().Format(time.RFC3339) + "\n")
	pillar.WriteString("\n")
	
	// System information
	pillar.WriteString("system:\n")
	pillar.WriteString(fmt.Sprintf("  hostname: %s\n", info.Hostname))
	pillar.WriteString(fmt.Sprintf("  platform: %s\n", info.Platform))
	pillar.WriteString(fmt.Sprintf("  architecture: %s\n", info.Architecture))
	pillar.WriteString(fmt.Sprintf("  kernel_version: %s\n", info.KernelVersion))
	pillar.WriteString(fmt.Sprintf("  uptime_seconds: %d\n", int(info.Uptime.Seconds())))
	pillar.WriteString("\n")
	
	// Hardware information
	pillar.WriteString("hardware:\n")
	pillar.WriteString(fmt.Sprintf("  cpu_cores: %d\n", info.CPUCores))
	pillar.WriteString(fmt.Sprintf("  memory_gb: %d\n", info.MemoryGB))
	pillar.WriteString(fmt.Sprintf("  disk_space_gb: %d\n", info.DiskSpaceGB))
	
	if len(info.LoadAverage) >= 3 {
		pillar.WriteString("  load_average:\n")
		pillar.WriteString(fmt.Sprintf("    1m: %.2f\n", info.LoadAverage[0]))
		pillar.WriteString(fmt.Sprintf("    5m: %.2f\n", info.LoadAverage[1]))
		pillar.WriteString(fmt.Sprintf("    15m: %.2f\n", info.LoadAverage[2]))
	}
	pillar.WriteString("\n")
	
	// Network information
	pillar.WriteString("network:\n")
	pillar.WriteString("  interfaces:\n")
	for _, iface := range info.NetworkIfaces {
		pillar.WriteString(fmt.Sprintf("    %s:\n", iface.Name))
		pillar.WriteString(fmt.Sprintf("      type: %s\n", iface.Type))
		pillar.WriteString(fmt.Sprintf("      mac: %s\n", iface.MAC))
		pillar.WriteString(fmt.Sprintf("      mtu: %d\n", iface.MTU))
		pillar.WriteString(fmt.Sprintf("      is_up: %v\n", iface.IsUp))
		pillar.WriteString(fmt.Sprintf("      is_public: %v\n", iface.IsPublic))
		
		if len(iface.IPv4) > 0 {
			pillar.WriteString("      ipv4:\n")
			for _, ip := range iface.IPv4 {
				pillar.WriteString(fmt.Sprintf("        - %s\n", ip))
			}
		}
		
		if len(iface.IPv6) > 0 {
			pillar.WriteString("      ipv6:\n")
			for _, ip := range iface.IPv6 {
				pillar.WriteString(fmt.Sprintf("        - %s\n", ip))
			}
		}
	}
	pillar.WriteString("\n")
	
	// Services information
	if len(info.Services) > 0 {
		pillar.WriteString("services:\n")
		for _, service := range info.Services {
			pillar.WriteString(fmt.Sprintf("  %s:\n", service.Name))
			pillar.WriteString(fmt.Sprintf("    status: %s\n", service.Status))
			if service.Port > 0 {
				pillar.WriteString(fmt.Sprintf("    port: %d\n", service.Port))
			}
			if service.ProcessID > 0 {
				pillar.WriteString(fmt.Sprintf("    process_id: %d\n", service.ProcessID))
			}
			if service.StartTime != "" {
				pillar.WriteString(fmt.Sprintf("    start_time: %s\n", service.StartTime))
			}
		}
		pillar.WriteString("\n")
	}
	
	// Salt information
	pillar.WriteString("salt:\n")
	pillar.WriteString(fmt.Sprintf("  mode: %s\n", info.SaltMode))
	if info.SaltVersion != "" {
		pillar.WriteString(fmt.Sprintf("  version: %s\n", info.SaltVersion))
	}
	pillar.WriteString("\n")
	
	// Docker information
	if info.DockerVersion != "" {
		pillar.WriteString("docker:\n")
		pillar.WriteString(fmt.Sprintf("  version: %s\n", info.DockerVersion))
		pillar.WriteString("  installed: true\n")
		pillar.WriteString("\n")
	}
	
	// Enrollment metadata
	pillar.WriteString("enrollment:\n")
	pillar.WriteString(fmt.Sprintf("  enrolled_at: %s\n", time.Now().Format(time.RFC3339)))
	pillar.WriteString("  enrolled_by: eos-self-enroll\n")
	pillar.WriteString("  managed_by: eos\n")
	
	return pillar.String()
}

// updateTopSLS updates the top.sls file to include the new node
func updateTopSLS(rc *eos_io.RuntimeContext, hostname, pillarDir string) error {
	logger := otelzap.Ctx(rc.Ctx)
	
	topSLSPath := filepath.Join(pillarDir, "top.sls")
	
	// Read existing top.sls or create new one
	var content string
	if data, err := os.ReadFile(topSLSPath); err == nil {
		content = string(data)
	} else {
		// Create new top.sls
		content = "# Salt pillar top file\n# Generated by eos self enroll\n\nbase:\n"
	}
	
	// Check if hostname is already in top.sls
	if strings.Contains(content, fmt.Sprintf("'%s':", hostname)) {
		logger.Debug("Hostname already in top.sls", zap.String("hostname", hostname))
		return nil
	}
	
	// Add the new node
	nodeEntry := fmt.Sprintf("  '%s':\n    - nodes.%s\n", hostname, hostname)
	
	// Find the base: section and add the entry
	lines := strings.Split(content, "\n")
	var newLines []string
	inBaseSection := false
	
	for _, line := range lines {
		newLines = append(newLines, line)
		
		if strings.TrimSpace(line) == "base:" {
			inBaseSection = true
		} else if inBaseSection && strings.HasPrefix(line, "  ") && strings.Contains(line, ":") {
			// We're in the base section and found a node entry
			continue
		} else if inBaseSection && !strings.HasPrefix(line, "  ") && strings.TrimSpace(line) != "" {
			// We've left the base section
			inBaseSection = false
		}
	}
	
	// If we're still in base section or didn't find it, add the entry
	if inBaseSection || !strings.Contains(content, "base:") {
		newLines = append(newLines, nodeEntry)
	}
	
	newContent := strings.Join(newLines, "\n")
	
	// Write updated top.sls
	if err := os.WriteFile(topSLSPath, []byte(newContent), 0644); err != nil {
		return fmt.Errorf("failed to write top.sls: %w", err)
	}
	
	logger.Info("Updated top.sls with new node", zap.String("hostname", hostname))
	return nil
}

// generateSystemFacts generates system facts for inventory
func generateSystemFacts(rc *eos_io.RuntimeContext, info *SystemInfo) error {
	logger := otelzap.Ctx(rc.Ctx)
	
	// Check if we're in dry-run mode
	if rc.Attributes != nil {
		if dryRun, exists := rc.Attributes["dry_run"]; exists && dryRun == "true" {
			logger.Info("DRY RUN: Would generate system facts")
			return nil
		}
	}
	
	// Create facts directory
	factsDir := "/var/lib/eos/facts"
	if err := os.MkdirAll(factsDir, 0755); err != nil {
		return fmt.Errorf("failed to create facts directory: %w", err)
	}
	
	// Generate JSON facts
	facts := map[string]interface{}{
		"system": map[string]interface{}{
			"hostname":      info.Hostname,
			"platform":      info.Platform,
			"architecture":  info.Architecture,
			"kernel_version": info.KernelVersion,
			"uptime":        info.Uptime.Seconds(),
			"discovered_at": time.Now().Format(time.RFC3339),
		},
		"hardware": map[string]interface{}{
			"cpu_cores":     info.CPUCores,
			"memory_gb":     info.MemoryGB,
			"disk_space_gb": info.DiskSpaceGB,
			"load_average":  info.LoadAverage,
		},
		"network": map[string]interface{}{
			"interfaces": info.NetworkIfaces,
		},
		"services": info.Services,
		"salt": map[string]interface{}{
			"mode":    info.SaltMode,
			"version": info.SaltVersion,
		},
	}
	
	if info.DockerVersion != "" {
		facts["docker"] = map[string]interface{}{
			"version":   info.DockerVersion,
			"installed": true,
		}
	}
	
	// Write facts to JSON file
	factsJSON, err := json.MarshalIndent(facts, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal facts: %w", err)
	}
	
	factsPath := filepath.Join(factsDir, "system.json")
	if err := os.WriteFile(factsPath, factsJSON, 0644); err != nil {
		return fmt.Errorf("failed to write facts file: %w", err)
	}
	
	logger.Info("System facts generated", zap.String("facts_path", factsPath))
	return nil
}

// exportToInventoryDatabase exports system information to inventory database
func exportToInventoryDatabase(rc *eos_io.RuntimeContext, info *SystemInfo) error {
	logger := otelzap.Ctx(rc.Ctx)
	
	// Check if we're in dry-run mode
	if rc.Attributes != nil {
		if dryRun, exists := rc.Attributes["dry_run"]; exists && dryRun == "true" {
			logger.Info("DRY RUN: Would export to inventory database")
			return nil
		}
	}
	
	// Try to connect to inventory database
	db, err := connectToInventoryDatabase(rc)
	if err != nil {
		return fmt.Errorf("failed to connect to inventory database: %w", err)
	}
	defer func() {
		if err := db.Close(); err != nil {
			logger.Warn("Failed to close database connection", zap.Error(err))
		}
	}()
	
	// Insert/update node record
	if err := insertOrUpdateNodeRecord(rc, db, info); err != nil {
		return fmt.Errorf("failed to insert/update node record: %w", err)
	}
	
	// Update service inventory
	if err := updateServiceInventory(rc, db, info); err != nil {
		return fmt.Errorf("failed to update service inventory: %w", err)
	}
	
	// Update network inventory
	if err := updateNetworkInventory(rc, db, info); err != nil {
		return fmt.Errorf("failed to update network inventory: %w", err)
	}
	
	// Create enrollment audit record
	if err := createEnrollmentAuditRecord(rc, db, info); err != nil {
		return fmt.Errorf("failed to create audit record: %w", err)
	}
	
	logger.Info("System information exported to inventory database successfully")
	return nil
}

// connectToInventoryDatabase connects to the inventory database
func connectToInventoryDatabase(rc *eos_io.RuntimeContext) (*sql.DB, error) {
	logger := otelzap.Ctx(rc.Ctx)
	
	// Try PostgreSQL connection
	if db, err := connectToPostgreSQL(rc); err == nil {
		logger.Debug("Connected to PostgreSQL inventory database")
		return db, nil
	}
	
	return nil, fmt.Errorf("no inventory database available")
}

// connectToPostgreSQL connects to PostgreSQL database
func connectToPostgreSQL(rc *eos_io.RuntimeContext) (*sql.DB, error) {
	// Try common PostgreSQL connection strings
	connectionStrings := []string{
		"host=localhost port=5432 dbname=eos_inventory user=eos password=eos sslmode=disable",
		"host=localhost port=5432 dbname=eos user=eos password=eos sslmode=disable",
		"host=postgres port=5432 dbname=eos_inventory user=eos password=eos sslmode=disable",
		"postgresql://eos:eos@localhost:5432/eos_inventory?sslmode=disable",
	}
	
	for _, connStr := range connectionStrings {
		db, err := sql.Open("postgres", connStr)
		if err != nil {
			continue
		}
		
		// Test connection
		if err := db.Ping(); err != nil {
			if err := db.Close(); err != nil {
				// Log error but continue trying other connections
			}
			continue
		}
		
		return db, nil
	}
	
	return nil, fmt.Errorf("failed to connect to PostgreSQL")
}


// insertOrUpdateNodeRecord inserts or updates node record in database
func insertOrUpdateNodeRecord(rc *eos_io.RuntimeContext, db *sql.DB, info *SystemInfo) error {
	query := `
	INSERT INTO nodes (
		hostname, platform, architecture, kernel_version,
		cpu_cores, memory_gb, disk_space_gb, salt_mode, salt_version, docker_version,
		updated_at
	) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, CURRENT_TIMESTAMP)
	ON CONFLICT (hostname) DO UPDATE SET
		platform = EXCLUDED.platform,
		architecture = EXCLUDED.architecture,
		kernel_version = EXCLUDED.kernel_version,
		cpu_cores = EXCLUDED.cpu_cores,
		memory_gb = EXCLUDED.memory_gb,
		disk_space_gb = EXCLUDED.disk_space_gb,
		salt_mode = EXCLUDED.salt_mode,
		salt_version = EXCLUDED.salt_version,
		docker_version = EXCLUDED.docker_version,
		updated_at = CURRENT_TIMESTAMP
	`
	
	_, err := db.Exec(query,
		info.Hostname,
		info.Platform,
		info.Architecture,
		info.KernelVersion,
		info.CPUCores,
		info.MemoryGB,
		info.DiskSpaceGB,
		info.SaltMode,
		info.SaltVersion,
		info.DockerVersion,
	)
	
	return err
}

// updateServiceInventory updates service inventory in database
func updateServiceInventory(rc *eos_io.RuntimeContext, db *sql.DB, info *SystemInfo) error {
	// Delete existing service records for this node
	_, err := db.Exec("DELETE FROM services WHERE node_hostname = $1", info.Hostname)
	if err != nil {
		return err
	}
	
	// Insert new service records
	for _, service := range info.Services {
		query := `
		INSERT INTO services (
			node_hostname, service_name, service_status, service_port,
			process_id, start_time, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP)
		`
		
		_, err := db.Exec(query,
			info.Hostname,
			service.Name,
			service.Status,
			service.Port,
			service.ProcessID,
			service.StartTime,
		)
		if err != nil {
			return err
		}
	}
	
	return nil
}

// updateNetworkInventory updates network inventory in database
func updateNetworkInventory(rc *eos_io.RuntimeContext, db *sql.DB, info *SystemInfo) error {
	// Delete existing network records for this node
	_, err := db.Exec("DELETE FROM network_interfaces WHERE node_hostname = $1", info.Hostname)
	if err != nil {
		return err
	}
	
	// Insert new network records
	for _, iface := range info.NetworkIfaces {
		query := `
		INSERT INTO network_interfaces (
			node_hostname, interface_name, interface_type, mac_address, mtu,
			is_up, is_public, ipv4_addresses, ipv6_addresses, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, CURRENT_TIMESTAMP)
		`
		
		// Convert IP address slices to JSON strings
		ipv4JSON, _ := json.Marshal(iface.IPv4)
		ipv6JSON, _ := json.Marshal(iface.IPv6)
		
		_, err := db.Exec(query,
			info.Hostname,
			iface.Name,
			iface.Type,
			iface.MAC,
			iface.MTU,
			iface.IsUp,
			iface.IsPublic,
			string(ipv4JSON),
			string(ipv6JSON),
		)
		if err != nil {
			return err
		}
	}
	
	return nil
}

// createEnrollmentAuditRecord creates an audit record for enrollment
func createEnrollmentAuditRecord(rc *eos_io.RuntimeContext, db *sql.DB, info *SystemInfo) error {
	query := `
	INSERT INTO enrollment_audit (
		node_hostname, enrollment_type, enrollment_status, enrollment_time, details
	) VALUES ($1, $2, $3, CURRENT_TIMESTAMP, $4)
	`
	
	details := fmt.Sprintf("System enrolled with %dGB RAM, %dGB disk, %d CPU cores",
		info.MemoryGB, info.DiskSpaceGB, info.CPUCores)
	
	_, err := db.Exec(query,
		info.Hostname,
		"self-enrollment",
		"completed",
		details,
	)
	
	return err
}

// generateTerraformData generates Terraform data for infrastructure management
func generateTerraformData(rc *eos_io.RuntimeContext, info *SystemInfo) error {
	logger := otelzap.Ctx(rc.Ctx)
	
	// Check if we're in dry-run mode
	if rc.Attributes != nil {
		if dryRun, exists := rc.Attributes["dry_run"]; exists && dryRun == "true" {
			logger.Info("DRY RUN: Would generate Terraform data")
			return nil
		}
	}
	
	// Create Terraform directory
	terraformDir := "/var/lib/eos/terraform"
	if err := os.MkdirAll(terraformDir, 0755); err != nil {
		return fmt.Errorf("failed to create terraform directory: %w", err)
	}
	
	// Generate Terraform resource definition
	terraformResource := generateTerraformResource(info)
	
	// Write to Terraform file
	hostname := strings.ToLower(strings.Split(info.Hostname, ".")[0])
	terraformPath := filepath.Join(terraformDir, fmt.Sprintf("%s.tf", hostname))
	
	if err := os.WriteFile(terraformPath, []byte(terraformResource), 0644); err != nil {
		return fmt.Errorf("failed to write terraform file: %w", err)
	}
	
	logger.Info("Terraform data generated", zap.String("terraform_path", terraformPath))
	return nil
}

// generateTerraformResource generates a Terraform resource definition
func generateTerraformResource(info *SystemInfo) string {
	var tf strings.Builder
	
	hostname := strings.ToLower(strings.Split(info.Hostname, ".")[0])
	
	// Header
	tf.WriteString("# Terraform resource for node: " + info.Hostname + "\n")
	tf.WriteString("# Generated by: eos self enroll\n")
	tf.WriteString("# Generated at: " + time.Now().Format(time.RFC3339) + "\n")
	tf.WriteString("\n")
	
	// Node resource
	tf.WriteString(fmt.Sprintf("resource \"eos_node\" \"%s\" {\n", hostname))
	tf.WriteString(fmt.Sprintf("  name         = \"%s\"\n", info.Hostname))
	tf.WriteString(fmt.Sprintf("  platform     = \"%s\"\n", info.Platform))
	tf.WriteString(fmt.Sprintf("  architecture = \"%s\"\n", info.Architecture))
	tf.WriteString("\n")
	
	// Hardware block
	tf.WriteString("  hardware {\n")
	tf.WriteString(fmt.Sprintf("    cpu_cores     = %d\n", info.CPUCores))
	tf.WriteString(fmt.Sprintf("    memory_gb     = %d\n", info.MemoryGB))
	tf.WriteString(fmt.Sprintf("    disk_space_gb = %d\n", info.DiskSpaceGB))
	tf.WriteString("  }\n")
	tf.WriteString("\n")
	
	// Network block
	if len(info.NetworkIfaces) > 0 {
		tf.WriteString("  network {\n")
		for _, iface := range info.NetworkIfaces {
			if iface.IsUp && iface.Type != "loopback" {
				tf.WriteString("    interface {\n")
				tf.WriteString(fmt.Sprintf("      name   = \"%s\"\n", iface.Name))
				tf.WriteString(fmt.Sprintf("      type   = \"%s\"\n", iface.Type))
				tf.WriteString(fmt.Sprintf("      mac    = \"%s\"\n", iface.MAC))
				tf.WriteString(fmt.Sprintf("      is_up  = %v\n", iface.IsUp))
				
				if len(iface.IPv4) > 0 {
					tf.WriteString("      ipv4 = [\n")
					for _, ip := range iface.IPv4 {
						tf.WriteString(fmt.Sprintf("        \"%s\",\n", ip))
					}
					tf.WriteString("      ]\n")
				}
				
				tf.WriteString("    }\n")
			}
		}
		tf.WriteString("  }\n")
		tf.WriteString("\n")
	}
	
	// Salt configuration
	tf.WriteString("  salt {\n")
	tf.WriteString(fmt.Sprintf("    mode    = \"%s\"\n", info.SaltMode))
	tf.WriteString(fmt.Sprintf("    version = \"%s\"\n", info.SaltVersion))
	tf.WriteString("  }\n")
	tf.WriteString("\n")
	
	// Services
	if len(info.Services) > 0 {
		tf.WriteString("  services = [\n")
		for _, service := range info.Services {
			tf.WriteString(fmt.Sprintf("    \"%s\",\n", service.Name))
		}
		tf.WriteString("  ]\n")
		tf.WriteString("\n")
	}
	
	// Tags
	tf.WriteString("  tags = {\n")
	tf.WriteString("    \"managed-by\"    = \"eos\"\n")
	tf.WriteString(fmt.Sprintf("    \"enrolled-at\"   = \"%s\"\n", time.Now().Format("2006-01-02")))
	tf.WriteString(fmt.Sprintf("    \"platform\"      = \"%s\"\n", info.Platform))
	tf.WriteString(fmt.Sprintf("    \"architecture\"  = \"%s\"\n", info.Architecture))
	tf.WriteString("  }\n")
	
	tf.WriteString("}\n")
	
	return tf.String()
}

// CreateInventoryBackup creates a backup of current inventory data
func CreateInventoryBackup(rc *eos_io.RuntimeContext) error {
	logger := otelzap.Ctx(rc.Ctx)
	
	// Check if we're in dry-run mode
	if rc.Attributes != nil {
		if dryRun, exists := rc.Attributes["dry_run"]; exists && dryRun == "true" {
			logger.Info("DRY RUN: Would create inventory backup")
			return nil
		}
	}
	
	backupDir := "/var/backups/eos-inventory"
	timestamp := time.Now().Format("20060102-150405")
	backupPath := filepath.Join(backupDir, fmt.Sprintf("inventory-backup-%s", timestamp))
	
	if err := os.MkdirAll(backupPath, 0755); err != nil {
		return fmt.Errorf("failed to create backup directory: %w", err)
	}
	
	// Backup directories to preserve
	backupDirs := map[string]string{
		"/srv/pillar":        "pillar",
		"/var/lib/eos/facts": "facts",
		"/var/lib/eos/terraform": "terraform",
	}
	
	for srcDir, destDir := range backupDirs {
		if _, err := os.Stat(srcDir); err == nil {
			destPath := filepath.Join(backupPath, destDir)
			if err := copyDirectory(srcDir, destPath); err != nil {
				logger.Warn("Failed to backup directory", 
					zap.String("src", srcDir),
					zap.String("dest", destPath),
					zap.Error(err))
			}
		}
	}
	
	logger.Info("Inventory backup created", zap.String("backup_path", backupPath))
	return nil
}

// ValidateInventoryExport validates the exported inventory data
func ValidateInventoryExport(rc *eos_io.RuntimeContext, info *SystemInfo) error {
	logger := otelzap.Ctx(rc.Ctx)
	
	// Check pillar file exists
	hostname := strings.ToLower(strings.Split(info.Hostname, ".")[0])
	pillarPath := filepath.Join("/srv/pillar/nodes", fmt.Sprintf("%s.sls", hostname))
	
	if _, err := os.Stat(pillarPath); err != nil {
		return fmt.Errorf("pillar file not found: %s", pillarPath)
	}
	
	// Check facts file exists
	factsPath := "/var/lib/eos/facts/system.json"
	if _, err := os.Stat(factsPath); err != nil {
		return fmt.Errorf("facts file not found: %s", factsPath)
	}
	
	// Validate JSON structure
	if data, err := os.ReadFile(factsPath); err == nil {
		var facts map[string]interface{}
		if err := json.Unmarshal(data, &facts); err != nil {
			return fmt.Errorf("invalid JSON in facts file: %w", err)
		}
		
		// Check required fields
		requiredFields := []string{"system", "hardware", "network"}
		for _, field := range requiredFields {
			if _, exists := facts[field]; !exists {
				return fmt.Errorf("missing required field in facts: %s", field)
			}
		}
	}
	
	logger.Info("Inventory export validation completed successfully")
	return nil
}