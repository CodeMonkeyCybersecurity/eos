//go:build linux

// pkg/kvm/consul_autoregister.go
// Automatic Consul agent installation and registration for KVM guests

package kvm

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/consul"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/execute"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/shared"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

// ConsulAutoRegisterConfig holds configuration for automatic Consul registration
type ConsulAutoRegisterConfig struct {
	VMName        string
	Environment   string   // dev, staging, production
	ConsulServers []string // IP addresses of Consul servers to join
	Datacenter    string   // Consul datacenter name
	NodeName      string   // Consul node name (defaults to VMName)
	Tags          []string // Service tags
	EnableConnect bool     // Enable Consul Connect
	TokenPath     string   // Optional: Path to Consul ACL token
}

// GenerateConsulCloudInit generates cloud-init configuration for Consul auto-registration
// This is idempotent - VM will install Consul and join cluster on first boot
func GenerateConsulCloudInit(rc *eos_io.RuntimeContext, config ConsulAutoRegisterConfig) (string, error) {
	logger := otelzap.Ctx(rc.Ctx)

	// ASSESS - Validate configuration
	if len(config.ConsulServers) == 0 {
		return "", fmt.Errorf("no Consul servers specified")
	}

	if config.Datacenter == "" {
		config.Datacenter = config.Environment
	}

	if config.NodeName == "" {
		config.NodeName = config.VMName
	}

	logger.Info("Generating Consul cloud-init config",
		zap.String("vm_name", config.VMName),
		zap.String("datacenter", config.Datacenter),
		zap.Strings("consul_servers", config.ConsulServers))

	// INTERVENE - Generate cloud-init YAML
	// Calculate directory path for binary extraction
	binaryDir := filepath.Dir(consul.ConsulBinaryPath)
	servicesHCLPath := filepath.Join(consul.ConsulConfigDir, "services.hcl")

	cloudInit := fmt.Sprintf(`#cloud-config

# Hostname configuration
hostname: %s
fqdn: %s.%s.consul

# Package updates
package_update: true
package_upgrade: false

# Install required packages
packages:
  - curl
  - unzip
  - jq

# Install and configure Consul
runcmd:
  # Install Consul binary
  - curl -fsSL https://releases.hashicorp.com/consul/%s/consul_%s_linux_amd64.zip -o /tmp/consul.zip
  - unzip -o /tmp/consul.zip -d %s
  - chmod +x %s
  - rm /tmp/consul.zip

  # Create Consul directories
  - mkdir -p %s
  - mkdir -p %s
  - mkdir -p %s

  # Create consul user
  - useradd --system --home %s --shell /bin/false %s || true
  - chown -R %s:%s %s
  - chown -R %s:%s %s
  - chown -R %s:%s %s

write_files:
  # Consul configuration
  - path: %s
    owner: %s:%s
    permissions: '%04o'
    content: |
      # Generated by Eos for VM: %%s
      # Environment: %%s
      # Datacenter: %%s

      datacenter = "%%s"
      data_dir = "%s"
      log_file = "%s"
      log_level = "INFO"

      # Client configuration
      client_addr = "0.0.0.0"
      bind_addr = "{{ GetDefaultPrivateIP }}"

      # Retry join - connect to Consul servers
      retry_join = [%%s]

      # Node metadata
      node_name = "%%s"
      node_meta = {
        "vm_name" = "%%s"
        "environment" = "%%s"
        "managed_by" = "eos"
        "created_at" = "{{ timestamp }}"
      }

      # Performance tuning
      performance {
        raft_multiplier = 1
      }

      # Enable local script checks
      enable_local_script_checks = true

      # Telemetry
      telemetry {
        prometheus_retention_time = "60s"
        disable_hostname = false
      }

%%s

  # Consul systemd service
  - path: /etc/systemd/system/%s.service
    permissions: '0644'
    content: |
      [Unit]
      Description=Consul Agent
      Documentation=https://www.consul.io/
      Requires=network-online.target
      After=network-online.target
      ConditionFileNotEmpty=%s

      [Service]
      Type=notify
      User=%s
      Group=%s
      ExecStart=%s agent -config-dir=%s
      ExecReload=/bin/kill --signal HUP $MAINPID
      KillMode=process
      KillSignal=SIGTERM
      Restart=on-failure
      RestartSec=5
      LimitNOFILE=65536

      [Install]
      WantedBy=multi-user.target

  # Service registration for this VM
  - path: %s
    owner: %s:%s
    permissions: '%04o'
    content: |
      # VM service registration
      service {
        name = "kvm-guest"
        id = "kvm-%%s"
        port = %d
        tags = [%%s]

        meta = {
          "vm_name" = "%%s"
          "environment" = "%%s"
        }

        check {
          id = "ssh"
          name = "SSH Port Check"
          tcp = "localhost:%d"
          interval = "30s"
          timeout = "5s"
        }

        check {
          id = "system-health"
          name = "System Health"
          script = "/usr/bin/systemctl is-system-running --quiet || exit 1"
          interval = "60s"
          timeout = "10s"
        }
      }

# Final commands to enable and start Consul
runcmd:
  # Reload systemd and start Consul
  - systemctl daemon-reload
  - systemctl enable %s
  - systemctl start %s

  # Wait for Consul to start
  - sleep 5

  # Store environment info in Consul K/V (idempotent)
  - %s kv put nodes/%%s/hostname "%%s"
  - %s kv put nodes/%%s/environment "%%s"
  - %s kv put nodes/%%s/created "$(date -Iseconds)"

  # Verify Consul is running
  - systemctl status %s --no-pager || true
  - %s members || true

power_state:
  mode: reboot
  delay: now
  message: "Rebooting after Consul installation"
  timeout: 300
  condition: true
`,
		// Hostname/FQDN (3 args)
		config.NodeName,
		config.NodeName,
		config.Datacenter,

		// Install Consul binary (4 args)
		consul.ConsulDefaultVersion,
		consul.ConsulDefaultVersion,
		binaryDir,
		consul.ConsulBinaryPath,

		// Create Consul directories (3 args)
		consul.ConsulConfigDir,
		consul.ConsulOptDir,
		consul.ConsulLogDir,

		// Create consul user (11 args)
		consul.ConsulConfigDir,
		consul.ConsulUser,
		consul.ConsulUser,
		consul.ConsulGroup,
		consul.ConsulConfigDir,
		consul.ConsulUser,
		consul.ConsulGroup,
		consul.ConsulOptDir,
		consul.ConsulUser,
		consul.ConsulGroup,
		consul.ConsulLogDir,

		// Consul configuration file (7 args + content placeholders)
		consul.ConsulConfigFile,
		consul.ConsulUser,
		consul.ConsulGroup,
		consul.ConsulConfigPerm,
		consul.ConsulOptDir,
		consul.ConsulLogDir,

		// Systemd service (6 args)
		consul.ConsulServiceName,
		consul.ConsulConfigFile,
		consul.ConsulUser,
		consul.ConsulGroup,
		consul.ConsulBinaryPath,
		consul.ConsulConfigDir,

		// Service registration (5 args)
		servicesHCLPath,
		consul.ConsulUser,
		consul.ConsulGroup,
		consul.ConsulConfigPerm,
		shared.PortSSH,
		shared.PortSSH,

		// Final runcmd (7 args)
		consul.ConsulServiceName,
		consul.ConsulServiceName,
		consul.ConsulBinaryPath,
		consul.ConsulBinaryPath,
		consul.ConsulBinaryPath,
		consul.ConsulServiceName,
		consul.ConsulBinaryPath,
	)

	// Now format the cloud-init with dynamic values
	cloudInit = fmt.Sprintf(cloudInit,
		// Consul config HCL content placeholders
		config.VMName,
		config.Environment,
		config.Datacenter,
		config.Datacenter,
		formatRetryJoin(config.ConsulServers),
		config.NodeName,
		config.VMName,
		config.Environment,

		// Consul Connect configuration (optional)
		generateConsulConnectConfig(config.EnableConnect),

		// Service registration content placeholders
		config.VMName,
		formatTags(config.Tags),
		config.VMName,
		config.Environment,

		// K/V storage
		config.NodeName,
		config.NodeName,
		config.NodeName,
		config.Environment,
		config.NodeName,
	)

	logger.Info("Generated Consul cloud-init configuration",
		zap.String("node_name", config.NodeName),
		zap.Int("config_size", len(cloudInit)))

	return cloudInit, nil
}

// WriteConsulCloudInitISO writes the cloud-init config to an ISO file
// This is idempotent - safe to call multiple times
func WriteConsulCloudInitISO(rc *eos_io.RuntimeContext, vmName string, cloudInit string) (string, error) {
	logger := otelzap.Ctx(rc.Ctx)

	// ASSESS - Create ISO directory structure
	isoDir := filepath.Join("/srv/iso", vmName)
	if err := os.MkdirAll(isoDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create ISO directory: %w", err)
	}

	// Write user-data
	userDataPath := filepath.Join(isoDir, "user-data")
	if err := os.WriteFile(userDataPath, []byte(cloudInit), 0644); err != nil {
		return "", fmt.Errorf("failed to write user-data: %w", err)
	}

	// Write meta-data
	metaData := fmt.Sprintf("instance-id: %s\nlocal-hostname: %s\n", vmName, vmName)
	metaDataPath := filepath.Join(isoDir, "meta-data")
	if err := os.WriteFile(metaDataPath, []byte(metaData), 0644); err != nil {
		return "", fmt.Errorf("failed to write meta-data: %w", err)
	}

	// Generate ISO
	isoPath := filepath.Join(isoDir, "cloud-init.iso")

	logger.Info("Generating cloud-init ISO",
		zap.String("iso_path", isoPath))

	if output, err := executeCommand(rc, "genisoimage",
		"-output", isoPath,
		"-volid", "cidata",
		"-joliet",
		"-rock",
		userDataPath,
		metaDataPath); err != nil {
		return "", fmt.Errorf("failed to generate ISO: %w\nOutput: %s", err, output)
	}

	// EVALUATE - Verify ISO was created
	if _, err := os.Stat(isoPath); err != nil {
		return "", fmt.Errorf("ISO file not created: %w", err)
	}

	logger.Info("Cloud-init ISO created successfully",
		zap.String("iso_path", isoPath))

	return isoPath, nil
}

// Helper functions

func formatRetryJoin(servers []string) string {
	quoted := make([]string, len(servers))
	for i, server := range servers {
		quoted[i] = fmt.Sprintf(`"%s"`, server)
	}
	return joinStrings(quoted, ", ")
}

func formatTags(tags []string) string {
	if len(tags) == 0 {
		return `"kvm-guest", "managed-by-eos"`
	}
	quoted := make([]string, len(tags))
	for i, tag := range tags {
		quoted[i] = fmt.Sprintf(`"%s"`, tag)
	}
	return joinStrings(quoted, ", ")
}

func generateConsulConnectConfig(enabled bool) string {
	if !enabled {
		return "  # Consul Connect disabled\n"
	}

	return fmt.Sprintf(`  # Enable Consul Connect
  connect {
    enabled = true
  }

  ports {
    grpc = %d
  }
`, consul.PortgRPC)
}

func joinStrings(strs []string, sep string) string {
	result := ""
	for i, s := range strs {
		if i > 0 {
			result += sep
		}
		result += s
	}
	return result
}

func executeCommand(rc *eos_io.RuntimeContext, cmd string, args ...string) (string, error) {
	return execute.Run(rc.Ctx, execute.Options{
		Command: cmd,
		Args:    args,
		Capture: true,
	})
}
