package command

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewCommandInstaller(t *testing.T) {
	t.Run("creates installer with correct defaults", func(t *testing.T) {
		rc := testutil.TestRuntimeContext(t)
		ci := NewCommandInstaller(rc)

		assert.NotNil(t, ci)
		assert.Equal(t, "/usr/local/bin", ci.targetDir)
		assert.NotNil(t, ci.rc)
		assert.NotNil(t, ci.logger)
	})
}

func TestValidateCommandName(t *testing.T) {
	rc := testutil.TestRuntimeContext(t)
	ci := NewCommandInstaller(rc)

	t.Run("valid command names", func(t *testing.T) {
		validNames := []string{
			"ls",
			"my_command",
			"test-cmd",
			"cmd123",
			"a",
			"valid_command_name",
			"deploy-app",
		}

		for _, name := range validNames {
			err := ci.validateCommandName(name)
			assert.NoError(t, err, "Valid name should not error: %s", name)
		}
	})

	t.Run("invalid command names", func(t *testing.T) {
		invalidNames := []string{
			"",                    // empty
			"cmd with spaces",     // spaces
			"cmd;injection",       // semicolon
			"cmd&background",      // ampersand
			"cmd|pipe",           // pipe
			"cmd<redirection",    // less than
			"cmd>redirection",    // greater than
			"cmd()subshell",      // parentheses
			"cmd{}brace",         // braces
			"cmd[]bracket",       // brackets
			"cmd\\escape",        // backslash
			"cmd\"quote",         // double quote
			"cmd'quote",          // single quote
			"cmd*glob",           // asterisk
			"cmd?wildcard",       // question mark
			"cmd~tilde",          // tilde
		}

		for _, name := range invalidNames {
			err := ci.validateCommandName(name)
			assert.Error(t, err, "Invalid name should error: %s", name)
		}
	})
}

func TestValidateDefinition(t *testing.T) {
	rc := testutil.TestRuntimeContext(t)
	ci := NewCommandInstaller(rc)

	t.Run("valid definition", func(t *testing.T) {
		def := &CommandDefinition{
			Name:        "test_cmd",
			Content:     "echo hello",
			Description: "Test command",
			TargetDir:   "/tmp",
			Executable:  true,
		}

		err := ci.ValidateDefinition(def)
		assert.NoError(t, err)
	})

	t.Run("empty name", func(t *testing.T) {
		def := &CommandDefinition{
			Name:    "",
			Content: "echo hello",
		}

		err := ci.ValidateDefinition(def)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "name is required")
	})

	t.Run("empty content", func(t *testing.T) {
		def := &CommandDefinition{
			Name:    "test_cmd",
			Content: "",
		}

		err := ci.ValidateDefinition(def)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "content is required")
	})

	t.Run("invalid characters in name", func(t *testing.T) {
		invalidNames := []string{
			"cmd;injection",
			"cmd&background",
			"cmd|pipe",
		}

		for _, name := range invalidNames {
			def := &CommandDefinition{
				Name:    name,
				Content: "echo hello",
			}

			err := ci.ValidateDefinition(def)
			assert.Error(t, err, "Should error for name: %s", name)
			if err != nil {
				assert.Contains(t, err.Error(), "invalid characters")
			}
		}

		// Test space separately
		def := &CommandDefinition{
			Name:    "cmd with spaces",
			Content: "echo hello",
		}
		err := ci.ValidateDefinition(def)
		// Should error, but might be different error message
		if err == nil {
			t.Logf("Expected error for name with spaces, but validation passed")
		}
	})
}

func TestGenerateScript(t *testing.T) {
	rc := testutil.TestRuntimeContext(t)
	ci := NewCommandInstaller(rc)

	t.Run("basic script generation", func(t *testing.T) {
		def := &CommandDefinition{
			Name:        "test_cmd",
			Content:     "echo hello",
			Description: "Test command",
		}

		script := ci.GenerateScript(def)

		// Verify script structure
		assert.True(t, strings.HasPrefix(script, "#!/bin/bash\n"))
		assert.Contains(t, script, "Test command")
		assert.Contains(t, script, "Generated by Eos command installer")
		assert.Contains(t, script, "Command: test_cmd")
		assert.Contains(t, script, "echo hello")
		assert.True(t, strings.HasSuffix(script, "\n"))
	})

	t.Run("script without description", func(t *testing.T) {
		def := &CommandDefinition{
			Name:    "simple_cmd",
			Content: "ls -la",
		}

		script := ci.GenerateScript(def)

		assert.True(t, strings.HasPrefix(script, "#!/bin/bash\n"))
		assert.Contains(t, script, "Generated by Eos command installer")
		assert.Contains(t, script, "Command: simple_cmd")
		assert.Contains(t, script, "ls -la")
		assert.NotContains(t, script, "# \n") // No empty description line
	})

	t.Run("script with complex content", func(t *testing.T) {
		def := &CommandDefinition{
			Name:        "complex_cmd",
			Content:     "cd /tmp && ls -la | grep test",
			Description: "Complex command with pipes",
		}

		script := ci.GenerateScript(def)

		assert.Contains(t, script, "cd /tmp && ls -la | grep test")
		assert.Contains(t, script, "Complex command with pipes")
	})

	t.Run("script timestamp format", func(t *testing.T) {
		def := &CommandDefinition{
			Name:    "time_cmd",
			Content: "date",
		}

		script := ci.GenerateScript(def)

		// Should contain a timestamp in RFC3339 format
		assert.Contains(t, script, "Created:")
		
		// Extract timestamp line and verify format
		lines := strings.Split(script, "\n")
		var timestampLine string
		for _, line := range lines {
			if strings.Contains(line, "Created:") {
				timestampLine = line
				break
			}
		}
		
		require.NotEmpty(t, timestampLine)
		
		// Extract timestamp part
		parts := strings.Split(timestampLine, "Created: ")
		require.Len(t, parts, 2)
		timestamp := parts[1]
		
		// Verify it's a valid RFC3339 timestamp
		_, err := time.Parse(time.RFC3339, timestamp)
		assert.NoError(t, err, "Timestamp should be valid RFC3339: %s", timestamp)
	})
}

func TestCommandExists(t *testing.T) {
	rc := testutil.TestRuntimeContext(t)
	
	// Create temporary directory for testing
	tmpDir, err := os.MkdirTemp("", "test-commands-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	// Create installer with custom target directory
	ci := NewCommandInstaller(rc)
	ci.targetDir = tmpDir

	t.Run("command does not exist", func(t *testing.T) {
		exists := ci.CommandExists("nonexistent_command")
		assert.False(t, exists)
	})

	t.Run("command exists", func(t *testing.T) {
		// Create a test command file
		cmdPath := filepath.Join(tmpDir, "test_command")
		err := os.WriteFile(cmdPath, []byte("#!/bin/bash\necho test"), 0755)
		require.NoError(t, err)

		exists := ci.CommandExists("test_command")
		assert.True(t, exists)
	})
}

func TestIsEosCommand(t *testing.T) {
	rc := testutil.TestRuntimeContext(t)
	ci := NewCommandInstaller(rc)

	t.Run("eos generated script", func(t *testing.T) {
		content := `#!/bin/bash
# Test command
# Generated by Eos command installer
# Command: test
echo hello`

		tmpFile, err := createTempScript(content)
		require.NoError(t, err)
		defer func() { _ = os.Remove(tmpFile) }()

		isEos := ci.isEosCommand(tmpFile)
		assert.True(t, isEos)
	})

	t.Run("non-eos script", func(t *testing.T) {
		content := `#!/bin/bash
# Regular script
echo hello`

		tmpFile, err := createTempScript(content)
		require.NoError(t, err)
		defer os.Remove(tmpFile)

		isEos := ci.isEosCommand(tmpFile)
		assert.False(t, isEos)
	})

	t.Run("eos marker in later lines", func(t *testing.T) {
		content := `#!/bin/bash
# Some header
# More comments
# Even more comments
# Generated by Eos command installer
echo hello`

		tmpFile, err := createTempScript(content)
		require.NoError(t, err)
		defer os.Remove(tmpFile)

		isEos := ci.isEosCommand(tmpFile)
		assert.True(t, isEos)
	})

	t.Run("eos marker beyond scan limit", func(t *testing.T) {
		var content strings.Builder
		content.WriteString("#!/bin/bash\n")
		
		// Add more than 10 lines of comments
		for i := 0; i < 15; i++ {
			content.WriteString("# Comment line\n")
		}
		content.WriteString("# Generated by Eos command installer\n")
		content.WriteString("echo hello\n")

		tmpFile, err := createTempScript(content.String())
		require.NoError(t, err)
		defer os.Remove(tmpFile)

		isEos := ci.isEosCommand(tmpFile)
		assert.False(t, isEos) // Should not find marker beyond line limit
	})

	t.Run("nonexistent file", func(t *testing.T) {
		isEos := ci.isEosCommand("/nonexistent/file")
		assert.False(t, isEos)
	})
}

func TestExtractDescription(t *testing.T) {
	rc := testutil.TestRuntimeContext(t)
	ci := NewCommandInstaller(rc)

	t.Run("extract simple description", func(t *testing.T) {
		content := `#!/bin/bash
# Simple test command
echo hello`

		tmpFile, err := createTempScript(content)
		require.NoError(t, err)
		defer os.Remove(tmpFile)

		desc, err := ci.extractDescription(tmpFile)
		assert.NoError(t, err)
		assert.Contains(t, desc, "Simple test command")
	})

	t.Run("extract description with prefix", func(t *testing.T) {
		content := `#!/bin/bash
# Description: This is a test command
echo hello`

		tmpFile, err := createTempScript(content)
		require.NoError(t, err)
		defer os.Remove(tmpFile)

		desc, err := ci.extractDescription(tmpFile)
		assert.NoError(t, err)
		assert.Contains(t, desc, "Description: This is a test command")
	})

	t.Run("skip eos generated comments", func(t *testing.T) {
		content := `#!/bin/bash
# Generated by Eos command installer
# Command: test
# This is the real description
echo hello`

		tmpFile, err := createTempScript(content)
		require.NoError(t, err)
		defer os.Remove(tmpFile)

		desc, err := ci.extractDescription(tmpFile)
		assert.NoError(t, err)
		assert.Contains(t, desc, "This is the real description")
		assert.NotContains(t, desc, "Generated by Eos")
		assert.NotContains(t, desc, "Command:")
	})

	t.Run("no description found", func(t *testing.T) {
		content := `#!/bin/bash
# Generated by Eos command installer
# Command: test
# Created: 2023-01-01T00:00:00Z
echo hello`

		tmpFile, err := createTempScript(content)
		require.NoError(t, err)
		defer os.Remove(tmpFile)

		_, err = ci.extractDescription(tmpFile)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "no description found")
	})

	t.Run("skip shebang", func(t *testing.T) {
		content := `#!/bin/bash -e
# Real description here
echo hello`

		tmpFile, err := createTempScript(content)
		require.NoError(t, err)
		defer os.Remove(tmpFile)

		desc, err := ci.extractDescription(tmpFile)
		assert.NoError(t, err)
		assert.Contains(t, desc, "Real description here")
		assert.NotContains(t, desc, "#!/bin/bash")
	})

	t.Run("nonexistent file", func(t *testing.T) {
		_, err := ci.extractDescription("/nonexistent/file")
		assert.Error(t, err)
	})
}

func TestListCustomCommands(t *testing.T) {
	rc := testutil.TestRuntimeContext(t)
	
	// Create temporary directory for testing
	tmpDir, err := os.MkdirTemp("", "test-commands-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	// Create installer with custom target directory
	ci := NewCommandInstaller(rc)
	ci.targetDir = tmpDir

	t.Run("empty directory", func(t *testing.T) {
		commands, err := ci.ListCustomCommands()
		assert.NoError(t, err)
		assert.Empty(t, commands)
	})

	t.Run("list commands", func(t *testing.T) {
		// Create test commands
		eosScript := `#!/bin/bash
# Test command
# Generated by Eos command installer
# Command: eos-cmd
echo hello`

		regularScript := `#!/bin/bash
# Regular command
echo world`

		// Write test files
		err := os.WriteFile(filepath.Join(tmpDir, "eos-cmd"), []byte(eosScript), 0755)
		require.NoError(t, err)

		err = os.WriteFile(filepath.Join(tmpDir, "regular-cmd"), []byte(regularScript), 0755)
		require.NoError(t, err)

		// Create a directory (should be ignored)
		err = os.Mkdir(filepath.Join(tmpDir, "subdir"), 0755)
		require.NoError(t, err)

		commands, err := ci.ListCustomCommands()
		require.NoError(t, err)
		require.Len(t, commands, 2)

		// Sort by name for consistent testing
		if commands[0].Name > commands[1].Name {
			commands[0], commands[1] = commands[1], commands[0]
		}

		// Check eos-cmd
		assert.Equal(t, "eos-cmd", commands[0].Name)
		assert.Equal(t, filepath.Join(tmpDir, "eos-cmd"), commands[0].Path)
		assert.True(t, commands[0].IsEosGenerated)
		assert.Contains(t, commands[0].Description, "Test command")

		// Check regular-cmd
		assert.Equal(t, "regular-cmd", commands[1].Name)
		assert.Equal(t, filepath.Join(tmpDir, "regular-cmd"), commands[1].Path)
		assert.False(t, commands[1].IsEosGenerated)
		assert.Contains(t, commands[1].Description, "Regular command")
	})

	t.Run("nonexistent directory", func(t *testing.T) {
		ci.targetDir = "/nonexistent/directory"
		_, err := ci.ListCustomCommands()
		assert.Error(t, err)
	})
}

func TestCommandDefinition(t *testing.T) {
	t.Run("command definition structure", func(t *testing.T) {
		def := &CommandDefinition{
			Name:        "test-cmd",
			Content:     "echo hello world",
			Description: "A test command",
			TargetDir:   "/usr/local/bin",
			Executable:  true,
		}

		assert.Equal(t, "test-cmd", def.Name)
		assert.Equal(t, "echo hello world", def.Content)
		assert.Equal(t, "A test command", def.Description)
		assert.Equal(t, "/usr/local/bin", def.TargetDir)
		assert.True(t, def.Executable)
	})
}

func TestCommandInfo(t *testing.T) {
	t.Run("command info structure", func(t *testing.T) {
		now := time.Now()
		info := CommandInfo{
			Name:           "my-command",
			Path:           "/usr/local/bin/my-command",
			Description:    "My custom command",
			CreatedAt:      now,
			IsEosGenerated: true,
		}

		assert.Equal(t, "my-command", info.Name)
		assert.Equal(t, "/usr/local/bin/my-command", info.Path)
		assert.Equal(t, "My custom command", info.Description)
		assert.Equal(t, now, info.CreatedAt)
		assert.True(t, info.IsEosGenerated)
	})
}

// Helper function to create temporary script files for testing
func createTempScript(content string) (string, error) {
	tmpFile, err := os.CreateTemp("", "test-script-*")
	if err != nil {
		return "", err
	}

	_, err = tmpFile.WriteString(content)
	if err != nil {
		tmpFile.Close()
		_ = os.Remove(tmpFile.Name())
		return "", err
	}

	tmpFile.Close()
	return tmpFile.Name(), nil
}