package orchestrator

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/openstack"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
)

// TerraformOrchestrator handles Terraform-based OpenStack deployment
type TerraformOrchestrator struct {
	WorkDir    string
	StateFile  string
	VarsFile   string
	BackendConfig map[string]string
}

// NewTerraformOrchestrator creates a new Terraform orchestrator
func NewTerraformOrchestrator(workDir string) *TerraformOrchestrator {
	return &TerraformOrchestrator{
		WorkDir:   workDir,
		StateFile: filepath.Join(workDir, "terraform.tfstate"),
		VarsFile:  filepath.Join(workDir, "terraform.tfvars.json"),
	}
}

// GenerateConfiguration generates Terraform configuration for OpenStack
func (t *TerraformOrchestrator) GenerateConfiguration(rc *eos_io.RuntimeContext, config *openstack.Config) error {
	logger := otelzap.Ctx(rc.Ctx)
	logger.Info("Generating Terraform configuration for OpenStack")

	// Create work directory
	if err := os.MkdirAll(t.WorkDir, 0755); err != nil {
		return fmt.Errorf("failed to create work directory: %w", err)
	}

	// Generate main.tf
	if err := t.generateMainTF(config); err != nil {
		return fmt.Errorf("failed to generate main.tf: %w", err)
	}

	// Generate variables.tf
	if err := t.generateVariablesTF(config); err != nil {
		return fmt.Errorf("failed to generate variables.tf: %w", err)
	}

	// Generate providers.tf
	if err := t.generateProvidersTF(config); err != nil {
		return fmt.Errorf("failed to generate providers.tf: %w", err)
	}

	// Generate modules based on deployment mode
	if err := t.generateModules(config); err != nil {
		return fmt.Errorf("failed to generate modules: %w", err)
	}

	// Generate tfvars file
	if err := t.generateTFVars(config); err != nil {
		return fmt.Errorf("failed to generate tfvars: %w", err)
	}

	logger.Info("Terraform configuration generated successfully")
	return nil
}

// generateMainTF creates the main Terraform configuration
func (t *TerraformOrchestrator) generateMainTF(config *openstack.Config) error {
	mainTF := `# OpenStack Infrastructure Deployment
# Generated by eos

terraform {
  required_version = ">= 1.0"
  
  required_providers {
    openstack = {
      source  = "terraform-provider-openstack/openstack"
      version = "~> 1.53.0"
    }
    null = {
      source  = "hashicorp/null"
      version = "~> 3.2.0"
    }
    local = {
      source  = "hashicorp/local"
      version = "~> 2.4.0"
    }
  }
  
  {{ if .BackendConfig }}
  backend "{{ .BackendType }}" {
    {{ range $k, $v := .BackendConfig }}
    {{ $k }} = "{{ $v }}"
    {{ end }}
  }
  {{ end }}
}

# Local variables
locals {
  deployment_mode = var.deployment_mode
  region         = var.region
  availability_zone = var.availability_zone
  
  common_tags = {
    Environment = var.environment
    ManagedBy   = "eos-terraform"
    DeployedAt  = timestamp()
  }
}

# Main deployment module
module "openstack_deployment" {
  source = "./modules/openstack-${var.deployment_mode}"
  
  # Common configuration
  admin_password    = var.admin_password
  service_password  = var.service_password
  db_password       = var.db_password
  rabbitmq_password = var.rabbitmq_password
  
  # Endpoints
  public_endpoint   = var.public_endpoint
  internal_endpoint = var.internal_endpoint
  admin_endpoint    = var.admin_endpoint
  
  # Network configuration
  network_type        = var.network_type
  provider_interface  = var.provider_interface
  provider_physnet    = var.provider_physnet
  management_network  = var.management_network
  
  # Storage configuration
  storage_backend = var.storage_backend
  ceph_monitors   = var.ceph_monitors
  nfs_server      = var.nfs_server
  nfs_path        = var.nfs_path
  
  # Features
  enable_dashboard = var.enable_dashboard
  enable_ssl       = var.enable_ssl
  
  # Integration
  vault_integration = var.vault_integration
  vault_address     = var.vault_address
  consul_integration = var.consul_integration
  consul_address     = var.consul_address
  
  # Resource allocation
  cpu_allocation_ratio  = var.cpu_allocation_ratio
  ram_allocation_ratio  = var.ram_allocation_ratio
  disk_allocation_ratio = var.disk_allocation_ratio
  
  tags = local.common_tags
}

# Outputs
output "keystone_auth_url" {
  value       = module.openstack_deployment.keystone_auth_url
  description = "Keystone authentication URL"
}

output "horizon_url" {
  value       = var.enable_dashboard ? module.openstack_deployment.horizon_url : null
  description = "Horizon dashboard URL"
}

output "admin_credentials" {
  value = {
    username = "admin"
    password = var.admin_password
    project  = "admin"
    domain   = "Default"
  }
  description = "Admin credentials for OpenStack"
  sensitive   = true
}

output "service_endpoints" {
  value       = module.openstack_deployment.service_endpoints
  description = "OpenStack service endpoints"
}
`

	tmpl, err := template.New("main").Parse(mainTF)
	if err != nil {
		return fmt.Errorf("failed to parse main.tf template: %w", err)
	}

	var buf bytes.Buffer
	data := map[string]interface{}{
		"BackendConfig": t.BackendConfig,
		"BackendType":   "consul", // or "s3", "azurerm", etc.
	}

	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute main.tf template: %w", err)
	}

	mainPath := filepath.Join(t.WorkDir, "main.tf")
	return os.WriteFile(mainPath, buf.Bytes(), 0644)
}

// generateVariablesTF creates the variables definition
func (t *TerraformOrchestrator) generateVariablesTF(config *openstack.Config) error {
	variablesTF := `# OpenStack Deployment Variables

variable "deployment_mode" {
  description = "OpenStack deployment mode"
  type        = string
  validation {
    condition     = contains(["all-in-one", "controller", "compute", "storage"], var.deployment_mode)
    error_message = "Invalid deployment mode."
  }
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "production"
}

variable "region" {
  description = "OpenStack region"
  type        = string
  default     = "RegionOne"
}

variable "availability_zone" {
  description = "Availability zone"
  type        = string
  default     = "nova"
}

# Authentication variables
variable "admin_password" {
  description = "Admin password for OpenStack"
  type        = string
  sensitive   = true
}

variable "service_password" {
  description = "Password for OpenStack services"
  type        = string
  sensitive   = true
}

variable "db_password" {
  description = "Database password"
  type        = string
  sensitive   = true
}

variable "rabbitmq_password" {
  description = "RabbitMQ password"
  type        = string
  sensitive   = true
}

# Endpoint variables
variable "public_endpoint" {
  description = "Public API endpoint"
  type        = string
}

variable "internal_endpoint" {
  description = "Internal API endpoint"
  type        = string
}

variable "admin_endpoint" {
  description = "Admin API endpoint"
  type        = string
}

# Network configuration
variable "network_type" {
  description = "Network type (provider, tenant, hybrid)"
  type        = string
  default     = "provider"
}

variable "provider_interface" {
  description = "Provider network interface"
  type        = string
  default     = ""
}

variable "provider_physnet" {
  description = "Provider physical network name"
  type        = string
  default     = "physnet1"
}

variable "management_network" {
  description = "Management network CIDR"
  type        = string
  default     = "10.0.0.0/24"
}

# Storage configuration
variable "storage_backend" {
  description = "Storage backend (lvm, ceph, nfs)"
  type        = string
  default     = "lvm"
}

variable "ceph_monitors" {
  description = "Ceph monitor addresses"
  type        = list(string)
  default     = []
}

variable "nfs_server" {
  description = "NFS server address"
  type        = string
  default     = ""
}

variable "nfs_path" {
  description = "NFS export path"
  type        = string
  default     = ""
}

# Feature flags
variable "enable_dashboard" {
  description = "Enable Horizon dashboard"
  type        = bool
  default     = true
}

variable "enable_ssl" {
  description = "Enable SSL/TLS"
  type        = bool
  default     = false
}

# Integration
variable "vault_integration" {
  description = "Enable Vault integration"
  type        = bool
  default     = false
}

variable "vault_address" {
  description = "Vault server address"
  type        = string
  default     = ""
}

variable "consul_integration" {
  description = "Enable Consul integration"
  type        = bool
  default     = false
}

variable "consul_address" {
  description = "Consul server address"
  type        = string
  default     = ""
}

# Resource allocation
variable "cpu_allocation_ratio" {
  description = "CPU allocation ratio for compute nodes"
  type        = number
  default     = 16.0
}

variable "ram_allocation_ratio" {
  description = "RAM allocation ratio for compute nodes"
  type        = number
  default     = 1.5
}

variable "disk_allocation_ratio" {
  description = "Disk allocation ratio for compute nodes"
  type        = number
  default     = 1.0
}
`

	variablesPath := filepath.Join(t.WorkDir, "variables.tf")
	return os.WriteFile(variablesPath, []byte(variablesTF), 0644)
}

// generateProvidersTF creates the providers configuration
func (t *TerraformOrchestrator) generateProvidersTF(config *openstack.Config) error {
	providersTF := `# Provider Configuration

# Configure the OpenStack Provider
provider "openstack" {
  auth_url    = "${var.internal_endpoint}:5000/v3"
  region      = var.region
  user_name   = "admin"
  password    = var.admin_password
  tenant_name = "admin"
  domain_name = "Default"
}

# Null provider for provisioning tasks
provider "null" {}

# Local provider for file operations
provider "local" {}
`

	providersPath := filepath.Join(t.WorkDir, "providers.tf")
	return os.WriteFile(providersPath, []byte(providersTF), 0644)
}

// generateModules creates module directories based on deployment mode
func (t *TerraformOrchestrator) generateModules(config *openstack.Config) error {
	// Create modules directory
	modulesDir := filepath.Join(t.WorkDir, "modules")
	if err := os.MkdirAll(modulesDir, 0755); err != nil {
		return fmt.Errorf("failed to create modules directory: %w", err)
	}

	// Generate module based on deployment mode
	switch config.Mode {
	case openstack.ModeAllInOne:
		return t.generateAllInOneModule(modulesDir)
	case openstack.ModeController:
		return t.generateControllerModule(modulesDir)
	case openstack.ModeCompute:
		return t.generateComputeModule(modulesDir)
	case openstack.ModeStorage:
		return t.generateStorageModule(modulesDir)
	default:
		return fmt.Errorf("unsupported deployment mode: %s", config.Mode)
	}
}

// generateAllInOneModule creates the all-in-one deployment module
func (t *TerraformOrchestrator) generateAllInOneModule(modulesDir string) error {
	moduleDir := filepath.Join(modulesDir, "openstack-all-in-one")
	if err := os.MkdirAll(moduleDir, 0755); err != nil {
		return err
	}

	// Main module file
	mainModule := `# All-in-One OpenStack Deployment Module

# Security groups
resource "openstack_compute_secgroup_v2" "openstack_services" {
  name        = "openstack-services"
  description = "Security group for OpenStack services"
  
  # API access
  rule {
    from_port   = 5000
    to_port     = 5000
    ip_protocol = "tcp"
    cidr        = "0.0.0.0/0"
  }
  
  # Horizon
  rule {
    from_port   = 80
    to_port     = 80
    ip_protocol = "tcp"
    cidr        = "0.0.0.0/0"
  }
  
  rule {
    from_port   = 443
    to_port     = 443
    ip_protocol = "tcp"
    cidr        = "0.0.0.0/0"
  }
  
  # Nova API
  rule {
    from_port   = 8774
    to_port     = 8774
    ip_protocol = "tcp"
    cidr        = "0.0.0.0/0"
  }
  
  # Neutron
  rule {
    from_port   = 9696
    to_port     = 9696
    ip_protocol = "tcp"
    cidr        = "0.0.0.0/0"
  }
  
  # Glance
  rule {
    from_port   = 9292
    to_port     = 9292
    ip_protocol = "tcp"
    cidr        = "0.0.0.0/0"
  }
  
  # Cinder
  rule {
    from_port   = 8776
    to_port     = 8776
    ip_protocol = "tcp"
    cidr        = "0.0.0.0/0"
  }
}

# Networks
resource "openstack_networking_network_v2" "management" {
  name           = "management"
  admin_state_up = true
}

resource "openstack_networking_subnet_v2" "management" {
  name       = "management-subnet"
  network_id = openstack_networking_network_v2.management.id
  cidr       = var.management_network
  ip_version = 4
  
  allocation_pool {
    start = cidrhost(var.management_network, 100)
    end   = cidrhost(var.management_network, 200)
  }
}

# External network (provider network)
resource "openstack_networking_network_v2" "external" {
  count = var.network_type == "provider" ? 1 : 0
  
  name           = "external"
  admin_state_up = true
  external       = true
  
  segments {
    physical_network = var.provider_physnet
    network_type     = "flat"
  }
}

# Flavors
resource "openstack_compute_flavor_v2" "tiny" {
  name      = "m1.tiny"
  ram       = 512
  vcpus     = 1
  disk      = 1
  is_public = true
}

resource "openstack_compute_flavor_v2" "small" {
  name      = "m1.small"
  ram       = 2048
  vcpus     = 1
  disk      = 20
  is_public = true
}

resource "openstack_compute_flavor_v2" "medium" {
  name      = "m1.medium"
  ram       = 4096
  vcpus     = 2
  disk      = 40
  is_public = true
}

resource "openstack_compute_flavor_v2" "large" {
  name      = "m1.large"
  ram       = 8192
  vcpus     = 4
  disk      = 80
  is_public = true
}

# Provisioner for post-deployment configuration
resource "null_resource" "post_deployment" {
  depends_on = [
    openstack_compute_secgroup_v2.openstack_services,
    openstack_networking_network_v2.management
  ]
  
  provisioner "local-exec" {
    command = <<-EOT
      echo "OpenStack deployment completed"
      echo "Keystone URL: ${var.public_endpoint}:5000/v3"
      ${var.enable_dashboard ? "echo 'Horizon URL: ${var.public_endpoint}'" : ""}
    EOT
  }
}

# Outputs
output "keystone_auth_url" {
  value = "${var.public_endpoint}:5000/v3"
}

output "horizon_url" {
  value = var.enable_dashboard ? var.public_endpoint : ""
}

output "service_endpoints" {
  value = {
    keystone = "${var.public_endpoint}:5000/v3"
    glance   = "${var.public_endpoint}:9292"
    nova     = "${var.public_endpoint}:8774/v2.1"
    neutron  = "${var.public_endpoint}:9696"
    cinder   = "${var.public_endpoint}:8776/v3"
  }
}
`

	// Write main.tf for the module
	mainPath := filepath.Join(moduleDir, "main.tf")
	if err := os.WriteFile(mainPath, []byte(mainModule), 0644); err != nil {
		return err
	}

	// Variables for the module
	moduleVars := `# Module input variables

variable "admin_password" {
  type = string
}

variable "service_password" {
  type = string
}

variable "db_password" {
  type = string
}

variable "rabbitmq_password" {
  type = string
}

variable "public_endpoint" {
  type = string
}

variable "internal_endpoint" {
  type = string
}

variable "admin_endpoint" {
  type = string
}

variable "network_type" {
  type = string
}

variable "provider_interface" {
  type = string
}

variable "provider_physnet" {
  type = string
}

variable "management_network" {
  type = string
}

variable "storage_backend" {
  type = string
}

variable "ceph_monitors" {
  type = list(string)
}

variable "nfs_server" {
  type = string
}

variable "nfs_path" {
  type = string
}

variable "enable_dashboard" {
  type = bool
}

variable "enable_ssl" {
  type = bool
}

variable "vault_integration" {
  type = bool
}

variable "vault_address" {
  type = string
}

variable "consul_integration" {
  type = bool
}

variable "consul_address" {
  type = string
}

variable "cpu_allocation_ratio" {
  type = number
}

variable "ram_allocation_ratio" {
  type = number
}

variable "disk_allocation_ratio" {
  type = number
}

variable "tags" {
  type = map(string)
}
`

	varsPath := filepath.Join(moduleDir, "variables.tf")
	return os.WriteFile(varsPath, []byte(moduleVars), 0644)
}

// generateTFVars creates the terraform.tfvars.json file
func (t *TerraformOrchestrator) generateTFVars(config *openstack.Config) error {
	vars := map[string]interface{}{
		"deployment_mode":       string(config.Mode),
		"admin_password":        config.AdminPassword,
		"service_password":      config.ServicePassword,
		"db_password":           config.DBPassword,
		"rabbitmq_password":     config.RabbitMQPassword,
		"public_endpoint":       config.PublicEndpoint,
		"internal_endpoint":     config.InternalEndpoint,
		"admin_endpoint":        config.AdminEndpoint,
		"network_type":          string(config.NetworkType),
		"provider_interface":    config.ProviderInterface,
		"provider_physnet":      config.ProviderPhysnet,
		"management_network":    config.ManagementNetwork,
		"storage_backend":       string(config.StorageBackend),
		"ceph_monitors":         config.CephMonitors,
		"nfs_server":            config.NFSServer,
		"nfs_path":              config.NFSExportPath,
		"enable_dashboard":      config.EnableDashboard,
		"enable_ssl":            config.EnableSSL,
		"vault_integration":     config.VaultIntegration,
		"vault_address":         config.VaultAddress,
		"consul_integration":    config.ConsulIntegration,
		"consul_address":        config.ConsulAddress,
		"cpu_allocation_ratio":  config.CPUAllocationRatio,
		"ram_allocation_ratio":  config.RAMAllocationRatio,
		"disk_allocation_ratio": config.DiskAllocationRatio,
	}

	data, err := json.MarshalIndent(vars, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal tfvars: %w", err)
	}

	return os.WriteFile(t.VarsFile, data, 0600)
}

// Apply runs terraform apply
func (t *TerraformOrchestrator) Apply(rc *eos_io.RuntimeContext, autoApprove bool) error {
	logger := otelzap.Ctx(rc.Ctx)
	logger.Info("Running Terraform apply")

	// Initialize Terraform
	if err := t.init(rc); err != nil {
		return fmt.Errorf("terraform init failed: %w", err)
	}

	// Plan
	if err := t.plan(rc); err != nil {
		return fmt.Errorf("terraform plan failed: %w", err)
	}

	// Apply
	args := []string{"apply", "-var-file", t.VarsFile}
	if autoApprove {
		args = append(args, "-auto-approve")
	}

	cmd := exec.CommandContext(rc.Ctx, "terraform", args...)
	cmd.Dir = t.WorkDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("terraform apply failed: %w", err)
	}

	logger.Info("Terraform apply completed successfully")
	return nil
}

// init runs terraform init
func (t *TerraformOrchestrator) init(rc *eos_io.RuntimeContext) error {
	cmd := exec.CommandContext(rc.Ctx, "terraform", "init")
	cmd.Dir = t.WorkDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

// plan runs terraform plan
func (t *TerraformOrchestrator) plan(rc *eos_io.RuntimeContext) error {
	cmd := exec.CommandContext(rc.Ctx, "terraform", "plan", "-var-file", t.VarsFile)
	cmd.Dir = t.WorkDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

// Destroy runs terraform destroy
func (t *TerraformOrchestrator) Destroy(rc *eos_io.RuntimeContext, autoApprove bool) error {
	logger := otelzap.Ctx(rc.Ctx)
	logger.Info("Running Terraform destroy")

	args := []string{"destroy", "-var-file", t.VarsFile}
	if autoApprove {
		args = append(args, "-auto-approve")
	}

	cmd := exec.CommandContext(rc.Ctx, "terraform", args...)
	cmd.Dir = t.WorkDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("terraform destroy failed: %w", err)
	}

	logger.Info("Terraform destroy completed successfully")
	return nil
}

// generateControllerModule creates the controller node deployment module
func (t *TerraformOrchestrator) generateControllerModule(modulesDir string) error {
	// TODO: Implement controller-specific module generation
	// This would include Keystone, Glance, Nova API, Neutron API, etc.
	return fmt.Errorf("controller module generation not yet implemented")
}

// generateComputeModule creates the compute node deployment module
func (t *TerraformOrchestrator) generateComputeModule(modulesDir string) error {
	// TODO: Implement compute-specific module generation
	// This would include Nova Compute, Neutron agents, etc.
	return fmt.Errorf("compute module generation not yet implemented")
}

// generateStorageModule creates the storage node deployment module
func (t *TerraformOrchestrator) generateStorageModule(modulesDir string) error {
	// TODO: Implement storage-specific module generation
	// This would include Cinder, Swift, Ceph configurations, etc.
	return fmt.Errorf("storage module generation not yet implemented")
}