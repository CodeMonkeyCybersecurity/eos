// pkg/shared/dotenv_test.go
// *Last Updated: 2025-10-28*

package shared

import (
	"os"
	"path/filepath"
	"testing"
)

func TestParseEnvFile(t *testing.T) {
	t.Parallel()
	tests := []struct {
		name        string
		content     string
		expected    map[string]string
		expectError bool
	}{
		{
			name: "simple key-value pairs",
			content: `DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres`,
			expected: map[string]string{
				"DB_HOST": "localhost",
				"DB_PORT": "5432",
				"DB_USER": "postgres",
			},
			expectError: false,
		},
		{
			name: "values with special characters",
			content: `PG_PASS=%P0&Ho_[re6ktPu)<_EHU_{,4MV3%:x8
AUTHENTIK_SECRET_KEY=:q7F&*cs96B)H5[t0u4qQ!RKJ}#JiwU3
AUTHENTIK_BOOTSTRAP_TOKEN=oaCbtQDfcWilabgkFyUSjPZVmSALiydb`,
			expected: map[string]string{
				"PG_PASS":                   "%P0&Ho_[re6ktPu)<_EHU_{,4MV3%:x8",
				"AUTHENTIK_SECRET_KEY":      ":q7F&*cs96B)H5[t0u4qQ!RKJ}#JiwU3",
				"AUTHENTIK_BOOTSTRAP_TOKEN": "oaCbtQDfcWilabgkFyUSjPZVmSALiydb",
			},
			expectError: false,
		},
		{
			name: "quoted values",
			content: `QUOTED_DOUBLE="value with spaces"
QUOTED_SINGLE='another value'
NO_QUOTES=plain`,
			expected: map[string]string{
				"QUOTED_DOUBLE": "value with spaces",
				"QUOTED_SINGLE": "another value",
				"NO_QUOTES":     "plain",
			},
			expectError: false,
		},
		{
			name: "comments and blank lines",
			content: `# This is a comment
DB_HOST=localhost

# Another comment
DB_PORT=5432

`,
			expected: map[string]string{
				"DB_HOST": "localhost",
				"DB_PORT": "5432",
			},
			expectError: false,
		},
		{
			name: "empty values",
			content: `AUTHENTIK_API_TOKEN=
EMPTY_VAR=
HAS_VALUE=something`,
			expected: map[string]string{
				"AUTHENTIK_API_TOKEN": "",
				"EMPTY_VAR":           "",
				"HAS_VALUE":           "something",
			},
			expectError: false,
		},
		{
			name: "whitespace handling",
			content: `  KEY1  =  value1
KEY2=value2
  KEY3="  value3  "`,
			expected: map[string]string{
				"KEY1": "value1",
				"KEY2": "value2",
				"KEY3": "  value3  ", // Preserves whitespace inside quotes
			},
			expectError: false,
		},
		{
			name: "real Hecate .env example",
			content: `# Hecate Environment Variables - Generated by EOS
# DO NOT commit this file to version control!

# PostgreSQL Database
PG_PASS=%P0&Ho_[re6ktPu)<_EHU_{,4MV3%:x8
PG_USER=authentik
PG_DB=authentik

# Authentik
AUTHENTIK_SECRET_KEY=:q7F&*cs96B)H5[t0u4qQ!RKJ}#JiwU3IK!lMc=<B*;i5:H:Z(0f5qLurr_OS>d(
AUTHENTIK_TAG=2025.10.0
AUTHENTIK_BOOTSTRAP_EMAIL=admin@localhost
AUTHENTIK_BOOTSTRAP_PASSWORD=fqst2i@(q-f&Tbn}8*J8g4kI8>v-uz-)
AUTHENTIK_BOOTSTRAP_TOKEN=oaCbtQDfcWilabgkFyUSjPZVmSALiydb

# Authentik API Token
AUTHENTIK_API_TOKEN=

# Ports
COMPOSE_PORT_HTTP=9000`,
			expected: map[string]string{
				"PG_PASS":                      "%P0&Ho_[re6ktPu)<_EHU_{,4MV3%:x8",
				"PG_USER":                      "authentik",
				"PG_DB":                        "authentik",
				"AUTHENTIK_SECRET_KEY":         ":q7F&*cs96B)H5[t0u4qQ!RKJ}#JiwU3IK!lMc=<B*;i5:H:Z(0f5qLurr_OS>d(",
				"AUTHENTIK_TAG":                "2025.10.0",
				"AUTHENTIK_BOOTSTRAP_EMAIL":    "admin@localhost",
				"AUTHENTIK_BOOTSTRAP_PASSWORD": "fqst2i@(q-f&Tbn}8*J8g4kI8>v-uz-)",
				"AUTHENTIK_BOOTSTRAP_TOKEN":    "oaCbtQDfcWilabgkFyUSjPZVmSALiydb",
				"AUTHENTIK_API_TOKEN":          "",
				"COMPOSE_PORT_HTTP":            "9000",
			},
			expectError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			// Create temporary .env file
			tmpDir := t.TempDir()
			envFile := filepath.Join(tmpDir, ".env")
			if err := os.WriteFile(envFile, []byte(tt.content), 0644); err != nil {
				t.Fatalf("Failed to create test .env file: %v", err)
			}

			// Parse the file
			result, err := ParseEnvFile(envFile)

			// Check error expectation
			if tt.expectError && err == nil {
				t.Errorf("Expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("Unexpected error: %v", err)
			}

			// Compare results
			if !tt.expectError {
				if len(result) != len(tt.expected) {
					t.Errorf("Expected %d variables, got %d", len(tt.expected), len(result))
				}

				for key, expectedValue := range tt.expected {
					if actualValue, found := result[key]; !found {
						t.Errorf("Expected key %s not found", key)
					} else if actualValue != expectedValue {
						t.Errorf("Key %s: expected value %q, got %q", key, expectedValue, actualValue)
					}
				}
			}
		})
	}
}

func TestGetEnvVar(t *testing.T) {
	t.Parallel()
	content := `DB_HOST=localhost
DB_PORT=5432
EMPTY_VAR=`

	tmpDir := t.TempDir()
	envFile := filepath.Join(tmpDir, ".env")
	if err := os.WriteFile(envFile, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to create test .env file: %v", err)
	}

	tests := []struct {
		name          string
		key           string
		expectedValue string
		expectedFound bool
	}{
		{"existing key", "DB_HOST", "localhost", true},
		{"empty value", "EMPTY_VAR", "", true},
		{"non-existent key", "MISSING_KEY", "", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			value, found, err := GetEnvVar(envFile, tt.key)
			if err != nil {
				t.Errorf("Unexpected error: %v", err)
			}
			if found != tt.expectedFound {
				t.Errorf("Expected found=%v, got %v", tt.expectedFound, found)
			}
			if value != tt.expectedValue {
				t.Errorf("Expected value %q, got %q", tt.expectedValue, value)
			}
		})
	}
}

func TestMustGetEnvVar(t *testing.T) {
	t.Parallel()
	content := `DB_HOST=localhost
EMPTY_VAR=`

	tmpDir := t.TempDir()
	envFile := filepath.Join(tmpDir, ".env")
	if err := os.WriteFile(envFile, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to create test .env file: %v", err)
	}

	tests := []struct {
		name        string
		key         string
		expectError bool
		errorMsg    string
	}{
		{"existing key", "DB_HOST", false, ""},
		{"non-existent key", "MISSING_KEY", true, "not found"},
		{"empty value", "EMPTY_VAR", true, "is empty"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			value, err := MustGetEnvVar(envFile, tt.key)

			if tt.expectError {
				if err == nil {
					t.Errorf("Expected error but got none")
				} else if tt.errorMsg != "" && !contains(err.Error(), tt.errorMsg) {
					t.Errorf("Expected error containing %q, got %q", tt.errorMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("Unexpected error: %v", err)
				}
				if value == "" {
					t.Errorf("Expected non-empty value")
				}
			}
		})
	}
}

func TestParseEnvFile_NonExistentFile(t *testing.T) {
	t.Parallel()
	_, err := ParseEnvFile("/nonexistent/path/.env")
	if err == nil {
		t.Errorf("Expected error for non-existent file")
	}
}

// Helper function
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > len(substr) &&
		(s[:len(substr)] == substr || s[len(s)-len(substr):] == substr ||
			len(s) > len(substr)*2 && s[len(s)/2-len(substr)/2:len(s)/2+len(substr)/2+len(substr)%2] == substr))
}
