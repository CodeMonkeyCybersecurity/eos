// pkg/wazuh/setup/configuration.go
// Configuration functions for Wazuh integration
//
// Created by Code Monkey Cybersecurity
// ABN: 77 177 673 061

package setup

import (
	"bufio"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"time"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/CodeMonkeyCybersecurity/eos/pkg/shared"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

// GetWebhookURL prompts the user for the webhook URL if not provided
func GetWebhookURL(rc *eos_io.RuntimeContext, config *Config, hookURLFlag string) error {
	logger := otelzap.Ctx(rc.Ctx)

	if hookURLFlag != "" {
		config.HookURL = hookURLFlag
		logger.Info("Using provided webhook URL", zap.String("url", config.HookURL))
		return nil
	}

	// Interactive prompt
	logger.Info("terminal prompt: Enter the Iris webhook URL")
	logger.Info("terminal prompt: Example: http://192.168.122.133:8080/webhook")

	reader := bufio.NewReader(os.Stdin)
	fmt.Print("URL: ")

	url, err := reader.ReadString('\n')
	if err != nil {
		return fmt.Errorf("failed to read input: %w", err)
	}

	config.HookURL = strings.TrimSpace(url)

	if config.HookURL == "" {
		return fmt.Errorf("webhook URL is required")
	}

	// Validate URL format
	if !strings.HasPrefix(config.HookURL, "http://") && !strings.HasPrefix(config.HookURL, "https://") {
		return fmt.Errorf("URL must start with http:// or https://")
	}

	logger.Info("Webhook URL configured", zap.String("url", config.HookURL))
	return nil
}

// GenerateWebhookToken generates a secure authentication token
func GenerateWebhookToken(rc *eos_io.RuntimeContext, config *Config) error {
	logger := otelzap.Ctx(rc.Ctx)

	// Generate 32-byte random token
	tokenBytes := make([]byte, 32)
	if _, err := rand.Read(tokenBytes); err != nil {
		return fmt.Errorf("failed to generate token: %w", err)
	}

	config.WebhookToken = hex.EncodeToString(tokenBytes)

	logger.Info("Generated secure authentication token",
		zap.String("token_preview", config.WebhookToken[:16]+"..."))

	return nil
}

// CreateEnvFile creates the .env file with webhook configuration
func CreateEnvFile(rc *eos_io.RuntimeContext, config *Config) error {
	logger := otelzap.Ctx(rc.Ctx)

	envPath := config.IntegrationsDir + "/.env"

	envContent := fmt.Sprintf(`# Iris Webhook Configuration
# Generated by eos create wazuh --webhook-out

HOOK_URL=%s
WEBHOOK_TOKEN=%s
`, config.HookURL, config.WebhookToken)

	if err := os.WriteFile(envPath, []byte(envContent), shared.SecureConfigFilePerm); err != nil {
		return fmt.Errorf("failed to write .env file: %w", err)
	}

	// Set ownership
	chownCmd := exec.Command("chown", "root:wazuh", envPath)
	if err := chownCmd.Run(); err != nil {
		logger.Warn("Could not set ownership on .env file",
			zap.String("path", envPath),
			zap.Error(err))
	}

	logger.Info("Environment configuration created",
		zap.String("path", envPath),
		zap.String("permissions", "640"))

	return nil
}

// UpdateOssecConf updates the ossec.conf with the integration block
func UpdateOssecConf(rc *eos_io.RuntimeContext, config *Config) error {
	logger := otelzap.Ctx(rc.Ctx)

	confPath := config.OssecConfPath

	// Backup first
	backupPath := fmt.Sprintf("%s.backup.%d", confPath, time.Now().Unix())
	if err := CopyFile(confPath, backupPath); err != nil {
		return fmt.Errorf("failed to backup ossec.conf: %w", err)
	}
	logger.Info("Configuration backed up", zap.String("backup", backupPath))

	// Read current config
	data, err := os.ReadFile(confPath)
	if err != nil {
		return fmt.Errorf("failed to read ossec.conf: %w", err)
	}

	content := string(data)

	// Check if integration already exists
	if strings.Contains(content, "<name>"+config.IntegrationName+"</name>") {
		logger.Warn("Integration already exists in ossec.conf")
		logger.Info("terminal prompt: Replace existing integration?")

		if !PromptYesNo("Replace existing integration?") {
			logger.Info("Skipping ossec.conf update")
			return nil
		}

		// Remove existing integration block
		content = RemoveExistingIntegration(content, config.IntegrationName)
	}

	// Add new integration block before last </ossec_config>
	integrationBlock := fmt.Sprintf(`
  <integration>
    <name>%s</name>
    <hook_url>%s</hook_url>
    <level>8</level>
    <alert_format>json</alert_format>
  </integration>

</ossec_config>`, config.IntegrationName, config.HookURL)

	// Replace the last </ossec_config> with our integration + closing tag
	content = strings.TrimSuffix(content, "</ossec_config>")
	content = strings.TrimSuffix(content, "\n")
	content += integrationBlock

	// Write updated config
	if err := os.WriteFile(confPath, []byte(content), shared.SecureConfigFilePerm); err != nil {
		return fmt.Errorf("failed to write ossec.conf: %w", err)
	}

	logger.Info("Integration added to ossec.conf",
		zap.String("integration", config.IntegrationName),
		zap.Int("alert_level", 8),
		zap.String("format", "json"))

	return nil
}

// RemoveExistingIntegration removes an existing integration block from ossec.conf content
func RemoveExistingIntegration(content, integrationName string) string {
	// Remove existing integration block using regex
	pattern := `(?s)<integration>\s*<name>` + regexp.QuoteMeta(integrationName) + `</name>.*?</integration>\s*`
	re := regexp.MustCompile(pattern)
	return re.ReplaceAllString(content, "")
}
