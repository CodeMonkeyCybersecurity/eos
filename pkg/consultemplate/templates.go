// pkg/consultemplate/templates.go
//
// Consul Template Rendering Helpers
//
// Provides utilities for creating and managing Consul Template templates
// that combine Vault secrets and Consul KV configuration.

package consultemplate

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

// TemplateManager manages Consul Template template files
type TemplateManager struct {
	rc     *eos_io.RuntimeContext
	logger otelzap.LoggerWithCtx
}

// NewTemplateManager creates a new template manager
func NewTemplateManager(rc *eos_io.RuntimeContext) *TemplateManager {
	return &TemplateManager{
		rc:     rc,
		logger: otelzap.Ctx(rc.Ctx),
	}
}

// TemplateContent defines the content of a template
type TemplateContent struct {
	Name        string            // Template name (e.g., "config.env")
	Content     string            // Template content (with {{ }} syntax)
	Destination string            // Where to render the file
	Perms       os.FileMode       // File permissions for rendered output
	Command     string            // Command to run after rendering (optional)
	VaultPaths  []string          // Vault paths used (for documentation)
	ConsulKeys  []string          // Consul KV keys used (for documentation)
	Variables   map[string]string // Variables and their descriptions
}

// CreateTemplate creates a template file for a service
func (tm *TemplateManager) CreateTemplate(serviceName string, tmpl *TemplateContent) error {
	tm.logger.Info("Creating template",
		zap.String("service", serviceName),
		zap.String("template", tmpl.Name))

	// Create service template directory
	templateDir := GetTemplatePath(serviceName, "")
	if err := os.MkdirAll(templateDir, TemplateDirPerm); err != nil {
		return fmt.Errorf("failed to create template directory: %w", err)
	}

	// Template file path
	templatePath := filepath.Join(templateDir, tmpl.Name+".ctmpl")

	// Build template content with header
	content := tm.buildTemplateWithHeader(tmpl)

	// Write template file
	if err := os.WriteFile(templatePath, []byte(content), TemplateFilePerm); err != nil {
		return fmt.Errorf("failed to write template file: %w", err)
	}

	tm.logger.Info("Template created successfully",
		zap.String("path", templatePath),
		zap.Int("size", len(content)))

	return nil
}

// buildTemplateWithHeader builds template content with documentation header
func (tm *TemplateManager) buildTemplateWithHeader(tmpl *TemplateContent) string {
	var content strings.Builder

	// Header with documentation
	content.WriteString("{{/* Consul Template for " + tmpl.Name + " */}}\n")
	content.WriteString("{{/* Generated by EOS */}}\n")
	content.WriteString("{{/* This template combines Vault secrets and Consul KV configuration */}}\n")
	content.WriteString("\n")

	// Document Vault paths used
	if len(tmpl.VaultPaths) > 0 {
		content.WriteString("{{/* Vault Secrets Used: */}}\n")
		for _, path := range tmpl.VaultPaths {
			content.WriteString("{{/*   - " + path + " */}}\n")
		}
		content.WriteString("\n")
	}

	// Document Consul KV keys used
	if len(tmpl.ConsulKeys) > 0 {
		content.WriteString("{{/* Consul KV Configuration Used: */}}\n")
		for _, key := range tmpl.ConsulKeys {
			content.WriteString("{{/*   - " + key + " */}}\n")
		}
		content.WriteString("\n")
	}

	// Document variables
	if len(tmpl.Variables) > 0 {
		content.WriteString("{{/* Variables: */}}\n")
		for variable, description := range tmpl.Variables {
			content.WriteString(fmt.Sprintf("{{/*   %s: %s */}}\n", variable, description))
		}
		content.WriteString("\n")
	}

	// Actual template content
	content.WriteString(tmpl.Content)

	return content.String()
}

// Common template helpers and examples

// BuildEnvFileTemplate creates a .env file template combining Vault and Consul
func BuildEnvFileTemplate(serviceName string, vaultSecrets, consulKeys []string) *TemplateContent {
	var content strings.Builder

	// Add secrets from Vault
	for _, secret := range vaultSecrets {
		// Extract variable name from Vault path
		// e.g., secret/bionicgpt/database_password -> DATABASE_PASSWORD
		parts := strings.Split(secret, "/")
		varName := strings.ToUpper(strings.ReplaceAll(parts[len(parts)-1], "-", "_"))

		content.WriteString(fmt.Sprintf("%s={{ with secret %q }}{{ .Data.data.value }}{{ end }}\n",
			varName, secret))
	}

	// Add configuration from Consul KV
	for _, key := range consulKeys {
		// Extract variable name from Consul key
		// e.g., config/bionicgpt/log_level -> LOG_LEVEL
		parts := strings.Split(key, "/")
		varName := strings.ToUpper(strings.ReplaceAll(parts[len(parts)-1], "-", "_"))

		content.WriteString(fmt.Sprintf("%s={{ key %q }}\n", varName, key))
	}

	return &TemplateContent{
		Name:        "config.env",
		Content:     content.String(),
		Destination: fmt.Sprintf("/opt/%s/.env", serviceName),
		Perms:       RenderedConfigPerm,
		Command:     fmt.Sprintf("docker compose -f /opt/%s/docker-compose.yml up -d --force-recreate", serviceName),
		VaultPaths:  vaultSecrets,
		ConsulKeys:  consulKeys,
		Variables:   make(map[string]string),
	}
}

// BuildJSONConfigTemplate creates a JSON config file template
func BuildJSONConfigTemplate(serviceName string, structure map[string]interface{}) *TemplateContent {
	var content strings.Builder

	content.WriteString("{\n")
	// Build JSON structure with template directives
	// This is a simplified example - real implementation would be more sophisticated
	for key, value := range structure {
		switch v := value.(type) {
		case string:
			if strings.HasPrefix(v, "vault:") {
				// Vault secret
				vaultPath := strings.TrimPrefix(v, "vault:")
				content.WriteString(fmt.Sprintf("  %q: {{ with secret %q }}{{ .Data.data.value | toJSON }}{{ end }},\n",
					key, vaultPath))
			} else if strings.HasPrefix(v, "consul:") {
				// Consul KV
				consulKey := strings.TrimPrefix(v, "consul:")
				content.WriteString(fmt.Sprintf("  %q: {{ key %q | toJSON }},\n",
					key, consulKey))
			} else {
				// Static value
				content.WriteString(fmt.Sprintf("  %q: %q,\n", key, v))
			}
		}
	}
	content.WriteString("}\n")

	return &TemplateContent{
		Name:        "config.json",
		Content:     content.String(),
		Destination: fmt.Sprintf("/opt/%s/config.json", serviceName),
		Perms:       RenderedConfigPerm,
	}
}

// BuildYAMLConfigTemplate creates a YAML config file template
func BuildYAMLConfigTemplate(serviceName string, structure map[string]interface{}) *TemplateContent {
	var content strings.Builder

	for key, value := range structure {
		switch v := value.(type) {
		case string:
			if strings.HasPrefix(v, "vault:") {
				vaultPath := strings.TrimPrefix(v, "vault:")
				content.WriteString(fmt.Sprintf("%s: {{ with secret %q }}{{ .Data.data.value }}{{ end }}\n",
					key, vaultPath))
			} else if strings.HasPrefix(v, "consul:") {
				consulKey := strings.TrimPrefix(v, "consul:")
				content.WriteString(fmt.Sprintf("%s: {{ key %q }}\n",
					key, consulKey))
			} else {
				content.WriteString(fmt.Sprintf("%s: %s\n", key, v))
			}
		}
	}

	return &TemplateContent{
		Name:        "config.yml",
		Content:     content.String(),
		Destination: fmt.Sprintf("/opt/%s/config.yml", serviceName),
		Perms:       RenderedConfigPerm,
	}
}

// Template Functions Documentation
const TemplateHelperDoc = `
Consul Template Function Reference
===================================

## Vault Functions

{{ with secret "secret/path" }}
  {{ .Data.data.value }}        # Read secret value
  {{ .Data.data.key }}           # Read specific key
{{ end }}

{{ $secret := secret "secret/path" }}
{{ $secret.Data.data.value }}   # Store in variable

## Consul KV Functions

{{ key "config/service/key" }}                    # Read KV value
{{ keyOrDefault "config/service/key" "default" }} # With default
{{ keyExists "config/service/key" }}              # Check existence

{{ range ls "config/service" }}
  {{ .Key }}: {{ .Value }}      # List all keys under prefix
{{ end }}

## Consul Service Discovery

{{ range service "service-name" }}
  {{ .Address }}:{{ .Port }}    # Service instances
{{ end }}

{{ with service "service-name" }}
  {{ range . }}
    {{ .ID }}                   # Service ID
    {{ .Node }}                 # Node name
    {{ .Address }}              # Service address
    {{ .Port }}                 # Service port
    {{ .Tags }}                 # Service tags
  {{ end }}
{{ end }}

## Utility Functions

{{ .Env.VAR_NAME }}             # Environment variable
{{ timestamp }}                 # Current timestamp
{{ timestamp "2006-01-02" }}    # Formatted timestamp
{{ env "PATH" }}                # Environment variable with env function
{{ file "/path/to/file" }}      # Read file content

## String Functions

{{ "hello" | toUpper }}         # HELLO
{{ "HELLO" | toLower }}         # hello
{{ "hello world" | replaceAll " " "_" }} # hello_world
{{ "  hello  " | trimSpace }}   # hello

## JSON Functions

{{ key "config/service/json" | parseJSON }} # Parse JSON
{{ $json := key "config/service/json" | parseJSON }}
{{ $json.field }}               # Access JSON field

## Conditionals

{{ if keyExists "config/service/enable" }}
  enabled
{{ else }}
  disabled
{{ end }}

{{ $value := key "config/service/key" }}
{{ if eq $value "true" }}
  Feature enabled
{{ end }}

## Loops

{{ range $key, $value := ls "config/service" }}
  {{ $key }}: {{ $value }}
{{ end }}

## Math Functions

{{ add 1 2 }}                   # 3
{{ subtract 5 3 }}              # 2
{{ multiply 2 3 }}              # 6
{{ divide 10 2 }}               # 5

## Best Practices

1. Always use 'with' for Vault secrets to handle missing secrets gracefully
2. Use keyOrDefault for Consul KV to provide fallback values
3. Document all Vault paths and Consul keys in template header
4. Use appropriate file permissions (0640 for secrets, 0644 for config)
5. Test templates with consul-template -dry-run before deployment
`

// GetTemplateHelperDoc returns the template helper documentation
func GetTemplateHelperDoc() string {
	return TemplateHelperDoc
}

// ValidateTemplateSyntax performs basic validation of template syntax
func (tm *TemplateManager) ValidateTemplateSyntax(content string) error {
	// Check for common syntax errors
	if strings.Count(content, "{{") != strings.Count(content, "}}") {
		return fmt.Errorf("unbalanced template delimiters: {{ and }}")
	}

	// Check for unclosed 'with' blocks
	withCount := strings.Count(content, "{{ with ")
	endCount := strings.Count(content, "{{ end }}")
	if withCount > endCount {
		return fmt.Errorf("unclosed 'with' block: %d 'with' found but only %d 'end'", withCount, endCount)
	}

	// Check for common mistakes
	if strings.Contains(content, "{{ .Data.value }}") {
		return fmt.Errorf("incorrect Vault secret syntax: use {{ .Data.data.value }} for KV v2")
	}

	return nil
}

// ListTemplates lists all templates for a service
func (tm *TemplateManager) ListTemplates(serviceName string) ([]string, error) {
	templateDir := GetTemplatePath(serviceName, "")

	entries, err := os.ReadDir(templateDir)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, fmt.Errorf("failed to read template directory: %w", err)
	}

	var templates []string
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".ctmpl") {
			templates = append(templates, entry.Name())
		}
	}

	return templates, nil
}

// DeleteTemplate removes a template file
func (tm *TemplateManager) DeleteTemplate(serviceName, templateName string) error {
	templatePath := filepath.Join(GetTemplatePath(serviceName, ""), templateName)

	tm.logger.Info("Deleting template",
		zap.String("service", serviceName),
		zap.String("template", templateName),
		zap.String("path", templatePath))

	if err := os.Remove(templatePath); err != nil {
		return fmt.Errorf("failed to delete template: %w", err)
	}

	return nil
}

// ReadTemplate reads a template file
func (tm *TemplateManager) ReadTemplate(serviceName, templateName string) (string, error) {
	templatePath := filepath.Join(GetTemplatePath(serviceName, ""), templateName)

	content, err := os.ReadFile(templatePath)
	if err != nil {
		return "", fmt.Errorf("failed to read template: %w", err)
	}

	return string(content), nil
}
