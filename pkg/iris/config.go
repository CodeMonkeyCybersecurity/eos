// pkg/iris/config.go

package iris

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
	"golang.org/x/term"
	"gopkg.in/yaml.v3"
)

// CreateConfigFile creates the Iris configuration file with the provided settings
//
// This function implements the Assess → Intervene → Evaluate pattern:
// - Assess: Validate configuration structure
// - Intervene: Generate and write config.yaml file
// - Evaluate: Verify YAML validity and check for placeholders
func CreateConfigFile(rc *eos_io.RuntimeContext, projectDir string, irisConfig IrisConfiguration) error {
	logger := otelzap.Ctx(rc.Ctx)

	logger.Debug("Creating Iris configuration file",
		zap.String("project_dir", projectDir))

	// INTERVENE - Generate config.yaml from template with actual values
	configYAML := fmt.Sprintf(`# Iris/Wazuh Configuration
# Generated by eos create iris

temporal:
  host_port: "%s"
  namespace: "%s"
  task_queue: "%s"

azure_openai:
  endpoint: "%s"
  api_key: "%s"
  deployment_name: "%s"
  api_version: "%s"

email:
  smtp_host: "%s"
  smtp_port: %d
  username: "%s"
  password: "%s"
  from: "%s"
  to: "%s"

webhook:
  port: %d

logging:
  level: "info"
  file: "logs/iris.log"
`,
		irisConfig.Temporal.HostPort,
		irisConfig.Temporal.Namespace,
		irisConfig.Temporal.TaskQueue,
		irisConfig.Azure.Endpoint,
		irisConfig.Azure.APIKey,
		irisConfig.Azure.DeploymentName,
		irisConfig.Azure.APIVersion,
		irisConfig.Email.SMTPHost,
		irisConfig.Email.SMTPPort,
		irisConfig.Email.Username,
		irisConfig.Email.Password,
		irisConfig.Email.From,
		irisConfig.Email.To,
		irisConfig.Webhook.Port,
	)

	configPath := filepath.Join(projectDir, "config.yaml")
	if err := os.WriteFile(configPath, []byte(configYAML), 0600); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	logger.Info("Configuration file created",
		zap.String("path", configPath),
		zap.String("permissions", "0600"))

	// EVALUATE - Validate YAML structure
	var testConfig map[string]interface{}
	if err := yaml.Unmarshal([]byte(configYAML), &testConfig); err != nil {
		logger.Warn("Generated YAML may be invalid", zap.Error(err))
	} else {
		logger.Debug("Configuration validated successfully")
	}

	// Warn if placeholders detected
	hasPlaceholders := strings.Contains(configYAML, "YOUR-")
	if hasPlaceholders {
		logger.Warn("IMPORTANT: Edit config.yaml with your actual credentials",
			zap.String("command", fmt.Sprintf("nano %s", configPath)))
	}

	return nil
}

// HasConfigFlags checks if any configuration flags were provided
func HasConfigFlags(azureEndpoint, azureAPIKey, smtpHost, smtpUsername string) bool {
	return azureEndpoint != "" || azureAPIKey != "" ||
		smtpHost != "" || smtpUsername != ""
}

// GetPlaceholderConfig returns a configuration with placeholder values
func GetPlaceholderConfig() IrisConfiguration {
	return IrisConfiguration{
		Azure: struct {
			Endpoint       string
			APIKey         string
			DeploymentName string
			APIVersion     string
		}{
			Endpoint:       "https://YOUR-RESOURCE.openai.azure.com/",
			APIKey:         "YOUR-AZURE-OPENAI-API-KEY",
			DeploymentName: "gpt-4o",
			APIVersion:     "2024-08-01-preview",
		},
		Email: struct {
			SMTPHost string
			SMTPPort int
			Username string
			Password string
			From     string
			To       string
		}{
			SMTPHost: "mail.cybermonkey.sh",
			SMTPPort: 587,
			Username: "alerts@cybermonkey.sh",
			Password: "YOUR-SMTP-PASSWORD",
			From:     "Wazuh Notify <alerts@cybermonkey.sh>",
			To:       "support@cybermonkey.net.au",
		},
		Webhook: struct{ Port int }{Port: 8080},
		Temporal: struct {
			HostPort  string
			Namespace string
			TaskQueue string
		}{
			HostPort:  "localhost:7233",
			Namespace: "default",
			TaskQueue: "wazuh-alerts",
		},
	}
}

// GetConfigFromFlags creates configuration from command-line flags
func GetConfigFromFlags(azureEndpoint, azureAPIKey, azureDeployment string,
	smtpHost string, smtpPort int, smtpUsername, smtpPassword string,
	emailFrom, emailTo string) IrisConfiguration {

	config := IrisConfiguration{
		Azure: struct {
			Endpoint       string
			APIKey         string
			DeploymentName string
			APIVersion     string
		}{
			Endpoint:       azureEndpoint,
			APIKey:         azureAPIKey,
			DeploymentName: azureDeployment,
			APIVersion:     "2024-08-01-preview",
		},
		Email: struct {
			SMTPHost string
			SMTPPort int
			Username string
			Password string
			From     string
			To       string
		}{
			SMTPHost: smtpHost,
			SMTPPort: smtpPort,
			Username: smtpUsername,
			Password: smtpPassword,
			From:     emailFrom,
			To:       emailTo,
		},
		Webhook: struct{ Port int }{Port: 8080},
		Temporal: struct {
			HostPort  string
			Namespace string
			TaskQueue string
		}{
			HostPort:  "localhost:7233",
			Namespace: "default",
			TaskQueue: "wazuh-alerts",
		},
	}

	// Fill in defaults if not provided
	if config.Azure.DeploymentName == "" {
		config.Azure.DeploymentName = "gpt-4o"
	}
	if config.Email.From == "" && config.Email.Username != "" {
		config.Email.From = fmt.Sprintf("Wazuh Notify <%s>", config.Email.Username)
	}

	return config
}

// GatherInteractiveConfig prompts the user for configuration values interactively
//
// This function implements the Assess → Intervene → Evaluate pattern:
// - Assess: Display prompts and gather user input
// - Intervene: Read and validate each configuration value
// - Evaluate: Confirm configuration before proceeding
func GatherInteractiveConfig(rc *eos_io.RuntimeContext, config *IrisConfiguration) error {
	logger := otelzap.Ctx(rc.Ctx)
	reader := bufio.NewReader(os.Stdin)

	logger.Info("terminal prompt: === Azure OpenAI Configuration ===")
	logger.Info("terminal prompt: Find these values in Azure Portal → Your OpenAI Resource")

	// Azure Endpoint
	for {
		logger.Info("terminal prompt: Azure OpenAI Endpoint (e.g., https://YOUR-RESOURCE.openai.azure.com/)")
		fmt.Print("Azure OpenAI Endpoint: ")
		config.Azure.Endpoint = strings.TrimSpace(mustReadLine(reader))

		if err := ValidateAzureEndpoint(config.Azure.Endpoint); err != nil {
			logger.Warn("Invalid endpoint", zap.Error(err))
			continue
		}
		break
	}

	// Azure API Key
	for {
		logger.Info("terminal prompt: Azure OpenAI API Key (hidden input)")
		fmt.Print("Azure OpenAI API Key: ")

		if password, err := term.ReadPassword(int(os.Stdin.Fd())); err == nil {
			fmt.Println() // New line after hidden input
			config.Azure.APIKey = strings.TrimSpace(string(password))
		} else {
			logger.Warn("Could not hide input", zap.Error(err))
			config.Azure.APIKey = strings.TrimSpace(mustReadLine(reader))
		}

		if config.Azure.APIKey == "" {
			logger.Warn("API key is required")
			continue
		}
		if len(config.Azure.APIKey) < 32 {
			logger.Warn("API key seems too short")
			continue
		}
		break
	}

	// Azure Deployment Name
	logger.Info("terminal prompt: Azure Deployment Name [default: gpt-4o]")
	fmt.Print("Azure Deployment Name: ")
	deploymentInput := strings.TrimSpace(mustReadLine(reader))
	if deploymentInput != "" {
		config.Azure.DeploymentName = deploymentInput
	}

	logger.Info("terminal prompt: ")
	logger.Info("terminal prompt: === Email (SMTP) Configuration ===")

	// SMTP Host
	for {
		logger.Info("terminal prompt: SMTP Host (e.g., smtp.gmail.com, mail.example.com)")
		fmt.Print("SMTP Host: ")
		config.Email.SMTPHost = strings.TrimSpace(mustReadLine(reader))

		if config.Email.SMTPHost == "" {
			logger.Warn("SMTP host is required")
			continue
		}
		break
	}

	// SMTP Port
	for {
		logger.Info("terminal prompt: SMTP Port [default: 587]")
		fmt.Print("SMTP Port: ")
		portInput := strings.TrimSpace(mustReadLine(reader))

		if portInput == "" {
			break // Use default (already set to 587)
		}

		var port int
		if _, err := fmt.Sscanf(portInput, "%d", &port); err != nil {
			logger.Warn("Invalid port number")
			continue
		}
		if port < 1 || port > 65535 {
			logger.Warn("Port must be between 1 and 65535")
			continue
		}
		config.Email.SMTPPort = port
		break
	}

	// SMTP Username
	for {
		logger.Info("terminal prompt: SMTP Username (email address)")
		fmt.Print("SMTP Username: ")
		config.Email.Username = strings.TrimSpace(mustReadLine(reader))

		if err := ValidateEmail(config.Email.Username); err != nil {
			logger.Warn("Invalid email", zap.Error(err))
			continue
		}
		break
	}

	// SMTP Password
	for {
		logger.Info("terminal prompt: SMTP Password (hidden input)")
		fmt.Print("SMTP Password: ")

		if password, err := term.ReadPassword(int(os.Stdin.Fd())); err == nil {
			fmt.Println() // New line after hidden input
			config.Email.Password = strings.TrimSpace(string(password))
		} else {
			logger.Warn("Could not hide input", zap.Error(err))
			config.Email.Password = strings.TrimSpace(mustReadLine(reader))
		}

		if config.Email.Password == "" {
			logger.Warn("SMTP password is required")
			continue
		}
		break
	}

	// Email From
	defaultFrom := fmt.Sprintf("Wazuh Notify <%s>", config.Email.Username)
	logger.Info("terminal prompt: From Email Address [default: "+defaultFrom+"]")
	fmt.Print("From Email: ")
	fromInput := strings.TrimSpace(mustReadLine(reader))
	if fromInput != "" {
		config.Email.From = fromInput
	} else {
		config.Email.From = defaultFrom
	}

	// Email To
	for {
		logger.Info("terminal prompt: To Email Address (alert recipient)")
		fmt.Print("To Email: ")
		config.Email.To = strings.TrimSpace(mustReadLine(reader))

		if err := ValidateEmail(config.Email.To); err != nil {
			logger.Warn("Invalid email", zap.Error(err))
			continue
		}
		break
	}

	// Confirmation
	logger.Info("terminal prompt: ")
	logger.Info("terminal prompt: === Configuration Summary ===")
	logger.Info("terminal prompt: Azure Endpoint: "+config.Azure.Endpoint)
	logger.Info("terminal prompt: Azure Deployment: "+config.Azure.DeploymentName)
	logger.Info("terminal prompt: SMTP Host: "+config.Email.SMTPHost)
	logger.Info("terminal prompt: SMTP User: "+config.Email.Username)
	logger.Info("terminal prompt: Email From: "+config.Email.From)
	logger.Info("terminal prompt: Email To: "+config.Email.To)
	logger.Info("terminal prompt: ")
	logger.Info("terminal prompt: Proceed with this configuration? (y/n)")
	fmt.Print("Proceed? (y/n): ")

	response := strings.TrimSpace(strings.ToLower(mustReadLine(reader)))
	if response != "y" && response != "yes" {
		return fmt.Errorf("configuration cancelled by user")
	}

	return nil
}

// ValidateAzureEndpoint validates an Azure OpenAI endpoint URL
func ValidateAzureEndpoint(endpoint string) error {
	if endpoint == "" {
		return fmt.Errorf("endpoint cannot be empty")
	}
	if !strings.HasPrefix(endpoint, "https://") {
		return fmt.Errorf("endpoint must start with https://")
	}
	if !strings.Contains(endpoint, ".openai.azure.com") {
		return fmt.Errorf("endpoint must contain .openai.azure.com")
	}
	if !strings.HasSuffix(endpoint, "/") {
		return fmt.Errorf("endpoint must end with /")
	}
	return nil
}

// ValidateEmail validates an email address format
func ValidateEmail(email string) error {
	if email == "" {
		return fmt.Errorf("email cannot be empty")
	}
	// Simple email validation
	if !strings.Contains(email, "@") || !strings.Contains(email, ".") {
		return fmt.Errorf("invalid email format")
	}
	return nil
}

// ValidateConfiguration validates the complete Iris configuration
func ValidateConfiguration(config IrisConfiguration) error {
	// Validate Azure
	if err := ValidateAzureEndpoint(config.Azure.Endpoint); err != nil {
		return fmt.Errorf("azure endpoint: %w", err)
	}
	if config.Azure.APIKey == "" || len(config.Azure.APIKey) < 32 {
		return fmt.Errorf("azure API key is required and must be at least 32 characters")
	}
	if config.Azure.DeploymentName == "" {
		return fmt.Errorf("azure deployment name is required")
	}

	// Validate Email
	if config.Email.SMTPHost == "" {
		return fmt.Errorf("SMTP host is required")
	}
	if config.Email.SMTPPort < 1 || config.Email.SMTPPort > 65535 {
		return fmt.Errorf("SMTP port must be between 1 and 65535")
	}
	if err := ValidateEmail(config.Email.Username); err != nil {
		return fmt.Errorf("SMTP username: %w", err)
	}
	if config.Email.Password == "" {
		return fmt.Errorf("SMTP password is required")
	}
	if err := ValidateEmail(config.Email.To); err != nil {
		return fmt.Errorf("email recipient: %w", err)
	}

	return nil
}

// mustReadLine reads a line from the reader and returns it
func mustReadLine(reader *bufio.Reader) string {
	input, err := reader.ReadString('\n')
	if err != nil {
		return ""
	}
	return strings.TrimSpace(input)
}
