// pkg/hecate/yaml_generator.go

package hecate

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"text/template"

	"github.com/CodeMonkeyCybersecurity/eos/pkg/eos_io"
	"github.com/uptrace/opentelemetry-go-extra/otelzap"
	"go.uber.org/zap"
)

const caddyfileTemplate = `# Hecate Caddyfile - Generated by EOS
# Global logging configuration
{
	log {
		output file /var/log/caddy/access.log
		format json
		level INFO
	}
}

# Security snippet - Block scanners and malicious patterns
(security) {
	@blocked {
		header Cf-Worker *
		header Cf-Connecting-Ip *
		header Cf-Ray *
	}
	respond @blocked 404

	@scanners {
		path /wp-admin/* /wp-login.php /wordpress/* /.git/* /.env /phpmyadmin/*
		path /config.json /.DS_Store /info.php /phpinfo.php /test.php
		path /telescope/* /horizon/* /pulse/*
		path /.well-known/security.txt /.svn/* /.hg/*
		path /backup/* /old/* /temp/* /tmp/* /sql/*
		path /admin/* /manager/* /shell.php
		path_regexp (/(vendor|node_modules|bower_components)/|\.(sql|bak|backup|log|old|orig|original|save|swp|tmp)$|\?rest_route=)
	}
	respond @scanners 404

	@suspicious_agents {
		header_regexp User-Agent (?i)(bot|crawler|spider|scraper|scan|exploit|nikto|sqlmap|havij|acunetix)
		header User-Agent "Go-http-client/1.1"
	}
	respond @suspicious_agents 444
}

# Common headers and settings
(cybermonkey_common) {
	import security
	encode gzip

	log {
		format json
		level INFO
	}

	header {
		X-Frame-Options "SAMEORIGIN"
		X-Content-Type-Options "nosniff"
		Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
		Referrer-Policy "strict-origin-when-cross-origin"
		X-XSS-Protection "1; mode=block"
		-Server
	}
}

{{range $name, $app := .Apps}}
# {{$name}} ({{$app.Type}})
{{$app.Domain}} {
	import cybermonkey_common
	{{if eq $app.LogLevel "DEBUG"}}
	log {
		output file /var/log/caddy/{{$name}}-{{$app.Type}}.log
		format json
		level DEBUG
	}
	{{end}}
	{{if $app.SSO}}
	# Authentik SSO forward auth
	forward_auth hecate-server-1:9000 {
		uri /outpost.goauthentik.io/auth/caddy
		copy_headers X-Authentik-Username X-Authentik-Groups X-Authentik-Email
	}
	{{if $app.SSOPublicPaths}}
	# Public paths (no authentication required)
	@public {
		path {{range $app.SSOPublicPaths}}{{.}}* {{end}}
	}
	handle @public {
		{{if and (eq $app.BackendProtocol "https") $app.TLSSkipVerify}}
		reverse_proxy {{$app.BackendProtocol}}://{{$app.Backend}}:{{$app.BackendPort}} {
			transport http {
				tls
				tls_insecure_skip_verify
			}
		}
		{{else}}
		reverse_proxy {{$app.BackendProtocol}}://{{$app.Backend}}:{{$app.BackendPort}}
		{{end}}
	}
	{{end}}
	{{end}}
	{{if and (eq $app.BackendProtocol "https") $app.TLSSkipVerify}}
	reverse_proxy {{$app.BackendProtocol}}://{{$app.Backend}}:{{$app.BackendPort}} {
		transport http {
			tls
			tls_insecure_skip_verify
		}
	}
	{{else}}
	reverse_proxy {{$app.BackendProtocol}}://{{$app.Backend}}:{{$app.BackendPort}}
	{{end}}
}

{{end}}
`

const dockerComposeTemplate = `# Hecate Docker Compose - Generated by EOS
services:
  caddy:
    image: caddy:latest
    container_name: hecate-caddy
    restart: always
    ports:
      - "80:80"
      - "443:443"
      - "443:443/udp"
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
      - ./logs/caddy:/var/log/caddy:rw
      - caddy_data:/data
      - caddy_config:/config
    networks:
      - hecate-net

{{if .NeedsNginx}}
  nginx:
    image: nginx
    container_name: hecate-nginx
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./conf.d:/etc/nginx/conf.d:ro
      - ./logs/nginx:/var/log/nginx
    ports:
{{range .TCPPorts}}      - "{{.}}:{{.}}"
{{end}}
    restart: always
    networks:
      - hecate-net
{{end}}

{{if .NeedsCoturn}}
  coturn:
    image: coturn/coturn
    restart: always
    container_name: hecate-coturn
    ports:
      - "3478:3478"
      - "3478:3478/udp"
      - "5349:5349"
      - "5349:5349/udp"
      - "49160-49200:49160-49200/udp"
    environment:
      DETECT_EXTERNAL_IP: "yes"
      DETECT_RELAY_IP: "yes"
    volumes:
      - ./certs:/etc/coturn/certs:ro
      - ./logs/coturn:/var/log
    command: >
      turnserver
      --listening-port=3478
      --listening-ip=0.0.0.0
      --fingerprint
      --no-cli
      --min-port=49160
      --max-port=49200
      --log-file=/var/log/coturn.log
      --cert=/etc/coturn/certs/hecate.fullchain.pem
      --pkey=/etc/coturn/certs/hecate.privkey.pem
      --static-auth-secret=yets-EIGHT-Bluk-Ep-Oc-LEFT_BRACKET
      --verbose
    networks:
      - hecate-net
{{end}}

{{if .HasAuthentik}}
  postgresql:
    image: docker.io/library/postgres:16-alpine
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -d $${POSTGRES_DB} -U $${POSTGRES_USER}"]
      start_period: 20s
      interval: 30s
      retries: 5
      timeout: 5s
    volumes:
      - database:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: $${PG_PASS:?database password required}
      POSTGRES_USER: $${PG_USER:-authentik}
      POSTGRES_DB: $${PG_DB:-authentik}
    env_file:
      - .env
    networks:
      - hecate-net

  redis:
    image: docker.io/library/redis:alpine
    command: --save 60 1 --loglevel warning
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "redis-cli ping | grep PONG"]
      start_period: 20s
      interval: 30s
      retries: 5
      timeout: 3s
    volumes:
      - redis:/data
    networks:
      - hecate-net

  server:
    image: $${AUTHENTIK_IMAGE:-ghcr.io/goauthentik/server}:$${AUTHENTIK_TAG:-2025.8}
    restart: unless-stopped
    command: server
    container_name: hecate-server-1
    environment:
      AUTHENTIK_SECRET_KEY: $${AUTHENTIK_SECRET_KEY:?secret key required}
      AUTHENTIK_REDIS__HOST: redis
      AUTHENTIK_POSTGRESQL__HOST: postgresql
      AUTHENTIK_POSTGRESQL__USER: $${PG_USER:-authentik}
      AUTHENTIK_POSTGRESQL__NAME: $${PG_DB:-authentik}
      AUTHENTIK_POSTGRESQL__PASSWORD: $${PG_PASS}
      AUTHENTIK_WORKER__THREADS: $${AUTHENTIK_WORKER__THREADS:-4}
    volumes:
      - ./media:/media
      - ./custom-templates:/templates
    env_file:
      - .env
    ports:
      - "$${COMPOSE_PORT_HTTP:-9000}:9000"
      - "$${COMPOSE_PORT_HTTPS:-9443}:9443"
    depends_on:
      postgresql:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - hecate-net

  worker:
    image: $${AUTHENTIK_IMAGE:-ghcr.io/goauthentik/server}:$${AUTHENTIK_TAG:-2025.8}
    restart: unless-stopped
    command: worker
    environment:
      AUTHENTIK_SECRET_KEY: $${AUTHENTIK_SECRET_KEY:?secret key required}
      AUTHENTIK_REDIS__HOST: redis
      AUTHENTIK_POSTGRESQL__HOST: postgresql
      AUTHENTIK_POSTGRESQL__USER: $${PG_USER:-authentik}
      AUTHENTIK_POSTGRESQL__NAME: $${PG_DB:-authentik}
      AUTHENTIK_POSTGRESQL__PASSWORD: $${PG_PASS}
      AUTHENTIK_WORKER__THREADS: $${AUTHENTIK_WORKER__THREADS:-4}
    user: root
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./media:/media
      - ./certs:/certs
      - ./custom-templates:/templates
    env_file:
      - .env
    depends_on:
      postgresql:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - hecate-net
{{end}}

networks:
  hecate-net:

volumes:
{{if .HasAuthentik}}  database:
    driver: local
  redis:
{{end}}  caddy_data:
  caddy_config:
`

type dockerComposeData struct {
	*YAMLHecateConfig
	TCPPorts []int
}

// GenerateFromYAML creates all infrastructure configuration files from a YAML config
//
// This function implements the Assess → Intervene → Evaluate pattern:
// - Assess: Validate output directory and YAML config
// - Intervene: Generate docker-compose.yml, Caddyfile, and optional nginx configs
// - Evaluate: Verify all files were created successfully
func GenerateFromYAML(rc *eos_io.RuntimeContext, config *YAMLHecateConfig, outputDir string) error {
	logger := otelzap.Ctx(rc.Ctx)

	logger.Info("Generating Hecate infrastructure from YAML",
		zap.String("output_dir", outputDir),
		zap.Int("app_count", len(config.Apps)))

	// ASSESS - Create output directory
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Create logs directories
	logsDir := filepath.Join(outputDir, "logs")
	if err := os.MkdirAll(filepath.Join(logsDir, "caddy"), 0755); err != nil {
		return fmt.Errorf("failed to create logs directory: %w", err)
	}

	// INTERVENE - Generate docker-compose.yml
	if err := generateYAMLDockerCompose(config, outputDir); err != nil {
		return fmt.Errorf("failed to generate docker-compose.yml: %w", err)
	}
	logger.Info("Generated docker-compose.yml")

	// Generate Caddyfile
	if err := generateYAMLCaddyfile(config, outputDir); err != nil {
		return fmt.Errorf("failed to generate Caddyfile: %w", err)
	}
	logger.Info("Generated Caddyfile")

	// Generate Nginx configs if needed
	if config.NeedsNginx {
		if err := generateYAMLNginxConfig(config, outputDir); err != nil {
			return fmt.Errorf("failed to generate nginx config: %w", err)
		}
		logger.Info("Generated nginx.conf")
	}

	// Generate .env file if Authentik is present
	if config.HasAuthentik {
		if err := generateYAMLEnvFile(rc, outputDir); err != nil {
			return fmt.Errorf("failed to generate .env file: %w", err)
		}
		logger.Info("Generated .env file")
	}

	logger.Info("Successfully generated all configuration files")
	return nil
}

// generateDockerCompose creates the docker-compose.yml file
func generateYAMLDockerCompose(config *YAMLHecateConfig, outputDir string) error {
	// Collect all TCP ports
	tcpPortsMap := make(map[int]bool)
	for _, app := range config.Apps {
		for port := range app.TCPPorts {
			tcpPortsMap[port] = true
		}
	}

	// Convert to sorted slice
	tcpPorts := make([]int, 0, len(tcpPortsMap))
	for port := range tcpPortsMap {
		tcpPorts = append(tcpPorts, port)
	}
	sort.Ints(tcpPorts)

	data := dockerComposeData{
		YAMLHecateConfig: config,
		TCPPorts:         tcpPorts,
	}

	tmpl, err := template.New("docker-compose").Parse(dockerComposeTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	outputPath := filepath.Join(outputDir, "docker-compose.yml")
	f, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

// generateCaddyfile creates the Caddyfile
func generateYAMLCaddyfile(config *YAMLHecateConfig, outputDir string) error {
	tmpl, err := template.New("caddyfile").Parse(caddyfileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	outputPath := filepath.Join(outputDir, "Caddyfile")
	f, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, config); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}

const nginxConfTemplate = `user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

stream {
    include /etc/nginx/conf.d/stream/*.conf;
}
`

const nginxStreamTemplate = `# {{.AppName}} TCP/UDP streams

{{range $extPort, $backendPort := .TCPPorts}}
upstream {{$.AppName}}_{{$extPort}} {
    server {{$.Backend}}:{{$backendPort}};
}
server {
    listen {{$extPort}};
    proxy_pass {{$.AppName}}_{{$extPort}};
}
{{end}}
`

type nginxStreamData struct {
	AppName  string
	Backend  string
	TCPPorts map[int]int
}

// generateNginxConfig creates nginx.conf and stream configs
func generateYAMLNginxConfig(config *YAMLHecateConfig, outputDir string) error {
	// Create nginx.conf
	nginxConfPath := filepath.Join(outputDir, "nginx.conf")
	if err := os.WriteFile(nginxConfPath, []byte(nginxConfTemplate), 0644); err != nil {
		return fmt.Errorf("failed to write nginx.conf: %w", err)
	}

	// Create stream directory
	streamDir := filepath.Join(outputDir, "conf.d", "stream")
	if err := os.MkdirAll(streamDir, 0755); err != nil {
		return fmt.Errorf("failed to create stream dir: %w", err)
	}

	// Create stream config for each app with TCP/UDP ports
	tmpl, err := template.New("nginx-stream").Parse(nginxStreamTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	for appName, app := range config.Apps {
		if len(app.TCPPorts) == 0 {
			continue
		}

		data := nginxStreamData{
			AppName:  appName,
			Backend:  app.Backend,
			TCPPorts: app.TCPPorts,
		}

		streamPath := filepath.Join(streamDir, fmt.Sprintf("%s.conf", appName))
		f, err := os.Create(streamPath)
		if err != nil {
			return fmt.Errorf("failed to create stream config: %w", err)
		}

		if err := tmpl.Execute(f, data); err != nil {
			f.Close()
			return fmt.Errorf("failed to execute template: %w", err)
		}
		f.Close()
	}

	return nil
}

// generateEnvFile creates a .env file with placeholder values for Authentik
func generateYAMLEnvFile(rc *eos_io.RuntimeContext, outputDir string) error {
	envContent := `# Hecate Environment Variables - Generated by EOS
# Fill in these values before running docker compose up

# PostgreSQL Database
PG_PASS=YOUR_SECURE_DATABASE_PASSWORD_HERE
PG_USER=authentik
PG_DB=authentik

# Authentik
AUTHENTIK_SECRET_KEY=YOUR_SECURE_SECRET_KEY_HERE
AUTHENTIK_TAG=2025.8
AUTHENTIK_IMAGE=ghcr.io/goauthentik/server
AUTHENTIK_WORKER__THREADS=4

# Ports
COMPOSE_PORT_HTTP=9000
COMPOSE_PORT_HTTPS=9443
`

	envPath := filepath.Join(outputDir, ".env")
	if err := os.WriteFile(envPath, []byte(envContent), 0600); err != nil {
		return fmt.Errorf("failed to write .env file: %w", err)
	}

	return nil
}
